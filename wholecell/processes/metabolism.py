#!/usr/bin/env python

"""
Metabolism

Metabolism sub-model. Encodes molecular simulation of microbial metabolism using flux-balance analysis.

TODO:
- move over to flexFBA
- implement metabolite pools
- enzyme-limited reactions (& fit enzyme expression)
- option to call a reduced form of metabolism (assume optimal)

@author: Derek Macklin
@organization: Covert Lab, Department of Bioengineering, Stanford University
@date: Created 4/2/2013
"""

from __future__ import division

import numpy as np

import wholecell.processes.process

from wholecell.utils.constants import REQUEST_PRIORITY_METABOLISM

class Metabolism(wholecell.processes.process.Process):
	""" Metabolism """

	_name = "Metabolism"

	# Constructor
	def __init__(self):
		super(Metabolism, self).__init__()

	# Construct object graph
	def initialize(self, sim, kb):
		super(Metabolism, self).initialize(sim, kb)

		self.fba = FluxBalanceAnalysis('arguments...')

		self.fba.externalMoleculeCountsIs('max # of molecules that can be used in a time step, defined by media/diffusion')

		self.molecules = self.bulkMoleculesView(self.fba.outputMoleculeIDs())

		self.enzymes = self.bulkMoleculesView('enzyme names')

		self.bulkMoleculeRequestPriorityIs(REQUEST_PRIORITY_METABOLISM)


	def calculateRequest(self):
		self.molecules.requestAll()


	# Calculate temporal evolution
	def evolveState(self):
		# Setup
		self.fba.internalMoleculeCountsIs(self.molecules.counts())
		self.fba.enzymeCountsIs(self.enzymes.counts())

		# Run
		self.fba.run()

		# Finalize
		self.molecules.countsIs(self.fba.outputMoleculeCounts())

		# TODO: record solution metadata, probably in a listener


# TODO: move below to a new file

# import numpy as np
import cvxopt
from collections import defaultdict

class FBAException(Exception):
	pass


class AlreadyExistsException(FBAException):
	pass


class DoesNotExistException(FBAException):
	pass


class FluxBalanceAnalysis(object):
	""" FluxBalanceAnalysis

	Solver for various FBA implementations.

	
	Required arguments:

	- reactionStoich, a dict of strings:dicts (reactionID:reaction stoich)
		Each value in the dict is a dict of molecule ID to stoichiometry pairs

	- externalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- objective, a dict of strings:floats (moleculeID:objective value)
		The meaning and usage of the objective will vary depending on the 
		formulation of FBA desired.

	
	Optional arguments (set to None for default behavior):

	- objectiveType, a string
		"standard": standard FBA objective (default)
		"flexible": flexFBA
		"pools": similar to FBA; optimizes towards desired pool concentrations

	- objectiveParameters, a dict
		Keys are specific to the FBA implementation.

	- internalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- reversibleReactions, a list of strings (reactionIDs for reversible reactions)

	- reactionEnzymes, a dict of strings:strings (reactionID:enzymeID)
	
	- reactionRates, a dict of strings:floats (reactionID:catalytic rate constant * dt)
		Used to set up the pseudo metabolites and boundary constraints needed
		for limiting reactions by enzyme counts.

	- moleculeMasses, a dict of floats (moleculeID:mass)
		Used in computing the net mass into the system.  Only needed and used 
		for moleculeIDs in externalExchangedMolecules.

	
	Caveats:
	
	There is no strict type checking, despite what the above may imply.

	During initialization, an exception will be raised if a reference is made 
	to an unutilized metabolite/enzyme/etc as described by the reaction 
	network.

	"""

	# Format strings for autogenerated IDs

	## Reverse reactions
	_generatedID_reverseReaction = "{} (reverse)"

	## Exchange fluxes
	_generatedID_externalExchange = "{} external exchange"

	## Objective
	_generatedID_moleculesToEquivalents = "molecules of {} to fractional objective equivalents"
	_generatedID_moleculeEquivalents = "fractional objective equivalent for {}"

	## Rate-constrained enzymes
	_generatedID_enzymeEquivRateConstrained = "{} equivalent (rate-constrained)"
	_generatedID_enzymeUsageRateConstrained = "{} usage (rate-constrained)"

	## Bool-constrained enzymes
	_generatedID_enzymeEquivBoolConstrained = "{} equivalent (bool-constrained)"
	_generatedID_enzymeUsageBoolConstrained = "{} usage (bool-constrained)"

	## Flex FBA
	_generatedID_fractionalDifferenceLeading = "difference between fractional objective equivalents of leading molecule and {}"
	_generatedID_fractionalDifferenceBiomass = "difference between fractional objective equivalents of {} and biomass objective"

	_generatedID_fractionsOut = "fractional objective equivalents of {} out"
	_generatedID_fractionalDifferenceLeadingOut = "difference between fractional objective equivalents of leading molecule and {} out"
	_generatedID_fractionalDifferenceBiomassOut = "difference between fractional objective equivalents of {} and biomass objective out"


	# Initialization

	def __init__(self, reactionStoich, externalExchangedMolecules, objective,
			objectiveType = None, objectiveParameters = None,
			internalExchangedMolecules = None, reversibleReactions = None, 
			reactionEnzymes = None, reactionRates = None, moleculeMasses = None):

		# Set up attributes

		self._nodeNames = []
		self._edgeNames = []

		# Set up running values for initialization

		## Used for creating the sparse matrix
		rowIndexes = []
		colIndexes = []
		values = []

		## Output calculations
		outputMoleculeIndexes = []
		outputReactionIndexes = []

		# Set up reversible reactions
		if reversibleReactions is not None:
			for reactionID in reversibleReactions:
				reverseReactionID = self._generatedID_reverseReaction.format(reactionID)
				
				reactionStoich[reverseReactionID] = {
					moleculeID:-stoichCoeff
					for moleculeID, stoichCoeff in reactionStoich[reactionID].viewitems()
					}

				if reactionEnzymes is not None and reactionEnzymes.has_key(reactionID):
					reactionEnzymes[reverseReactionID] = reactionEnzymes[reactionID]

				if reactionRates is not None and reactionRates.has_key(reactionID):
					reactionRates[reverseReactionID] = reactionRates[reactionID]

		# Parses reaction data
		reactionIndexes = []

		for reactionID, stoichiometry in reactionStoich.viewitems():
			colIndex = self._edgeAdd(reactionID)

			for moleculeID, stoichCoeff in stoichiometry.viewitems():
				rowIndex = self._nodeIndex(moleculeID, True)

				rowIndexes.append(rowIndex)
				colIndexes.append(colIndex)
				values.append(stoichCoeff)

			reactionIndexes.append(colIndex)

		self._reactionIndexes = np.array(reactionIndexes)

		# Add external exchange reactions

		externalExchangeIndexes = []

		for moleculeID in externalExchangedMolecules:
			exchangeID = self._generatedID_externalExchange.format(moleculeID)

			colIndex = self._edgeAdd(exchangeID)
			rowIndex = self._nodeIndex(moleculeID)

			# NOTE: The convention, if I am not mistaken, is to define 
			# exchanges as pointing out of the system, even though it is common
			# to think of exchanges as inputs.  Regardless this choice should 
			# have no impact outside of this class.

			rowIndexes.append(rowIndex)
			colIndexes.append(colIndex)
			values.append(-1)

			externalExchangeIndexes.append(colIndex)

		self._externalExchangeIndexes = np.array(externalExchangeIndexes)

		# Set up the objective

		## First, set up the molecule count -> objective equivalents flux

		objectiveEquivalentIndexes = []

		for moleculeID, coeff in objective.viewitems():
			molecule_rowIndex = self._nodeIndex(moleculeID)

			pseudoFluxID = self._generatedID_moleculesToEquivalents.format(moleculeID)
			colIndex = self._edgeAdd(pseudoFluxID)

			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)
			objectiveEquiv_rowIndex = self._nodeAdd(objectiveEquivID)

			rowIndexes.append(molecule_rowIndex)
			colIndexes.append(colIndex)
			values.append(-coeff)

			rowIndexes.append(objectiveEquiv_rowIndex)
			colIndexes.append(colIndex)
			values.append(+1)

			outputMoleculeIndexes.append(molecule_rowIndex)
			objectiveEquivalentIndexes.append(objectiveEquiv_rowIndex)

			outputReactionIndexes.append(colIndex)

		## Next, set up the actual objective function (implementation varies)
		objIndexes = []
		objValues = []

		if objectiveType is None or objectiveType == "standard":
			objectiveID = "Standard FBA objective reaction"

			colIndex = self._edgeAdd(objectiveID)

			nObjectiveEquivalents = len(objectiveEquivalentIndexes)

			rowIndexes.extend(objectiveEquivalentIndexes)
			colIndexes.extend([colIndex]*nObjectiveEquivalents)
			values.extend([-1]*nObjectiveEquivalents)

			objIndexes.append(colIndex)
			objValues.append(+1)

		elif objectiveType == "flexible":
			# Load parameters
			leadingMoleculeID = objectiveParameters["leading molecule ID"]

			if not objective.has_key(leadingMoleculeID):
				raise FBAException("flexFBA leading molecule must be in the objective")

			fractionalDifferenceWeight = objectiveParameters["gamma"]
			biomassSatisfactionWeight = objectiveParameters["beta"]

			# _generatedID_fractionalDifferenceLeading
			# _generatedID_fractionalDifferenceBiomass

			# _generatedID_fractionsOut
			# _generatedID_fractionalDifferenceLeadingOut
			# _generatedID_fractionalDifferenceBiomassOut

			biomass_colIndex = self._edgeAdd("Standard biomass objective")

			# Add biomass to objective
			objIndexes.append(biomass_colIndex)
			objValues.append(biomassSatisfactionWeight)

			# Create fraction and biomass outputs
			for moleculeID in objective.viewkeys():
				fractionID = self._generatedID_moleculeEquivalents.format(moleculeID)
				fraction_rowIndex = self._nodeIndex(fractionID)

				# Biomass out
				rowIndexes.append(fraction_rowIndex)
				colIndexes.append(biomass_colIndex)
				values.append(-1)

				# Fraction out
				fractionOutID = self._generatedID_fractionsOut.format(moleculeID)
				fractionOut_colIndex = self._edgeAdd(fractionOutID)

				rowIndexes.append(fraction_rowIndex)
				colIndexes.append(fractionOut_colIndex)
				values.append(-1)

				if moleculeID == leadingMoleculeID:
					# Add leading molecule to objective
					objIndexes.append(fractionOut_colIndex)
					objValues.append(+1)

			# Create fraction differences (leading - other), used in objective and constraints
			leadingMoleculeToFractionID = self._generatedID_moleculesToEquivalents.format(leadingMoleculeID)
			leadingMoleculeToFraction_colIndex = self._edgeIndex(leadingMoleculeToFractionID)

			for moleculeID in objective.viewkeys():
				if moleculeID == leadingMoleculeID:
					continue

				fractionDifferenceLeadingID = self._generatedID_fractionalDifferenceLeading.format(moleculeID)
				fractionDifferenceLeading_rowIndex = self._nodeAdd(fractionDifferenceLeadingID)

				rowIndexes.append(fractionDifferenceLeading_rowIndex)
				colIndexes.append(leadingMoleculeToFraction_colIndex)
				values.append(+1)
				
				moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)
				moleculeToFraction_colIndex = self._edgeIndex(moleculeToFractionID)

				rowIndexes.append(fractionDifferenceLeading_rowIndex)
				colIndexes.append(moleculeToFraction_colIndex)
				values.append(-1)

				fractionDifferenceLeadingOutID = self._generatedID_fractionalDifferenceLeadingOut.format(moleculeID)
				fractionDifferenceLeadingOut_colIndex = self._edgeAdd(fractionDifferenceLeadingOutID)

				rowIndexes.append(fractionDifferenceLeading_rowIndex)
				colIndexes.append(fractionDifferenceLeadingOut_colIndex)
				values.append(-1)

				objIndexes.append(fractionDifferenceLeadingOut_colIndex)
				objValues.append(-fractionalDifferenceWeight)

			# Create biomass differences (fraction - biomass), used in constraints

			for moleculeID in objective.viewkeys():
				fractionDifferenceBiomassID = self._generatedID_fractionalDifferenceBiomass.format(moleculeID)
				fractionDifferenceBiomass_rowIndex = self._nodeAdd(fractionDifferenceBiomassID)

				moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)
				moleculeToFraction_colIndex = self._edgeIndex(moleculeToFractionID)

				rowIndexes.append(fractionDifferenceBiomass_rowIndex)
				colIndexes.append(moleculeToFraction_colIndex)
				values.append(+1)

				rowIndexes.append(fractionDifferenceBiomass_rowIndex)
				colIndexes.append(biomass_colIndex)
				values.append(-1)

				fractionDifferenceBiomassOutID = self._generatedID_fractionalDifferenceBiomassOut.format(moleculeID)
				fractionDifferenceBiomassOut_colIndex = self._edgeAdd(fractionDifferenceBiomassOutID)

				rowIndexes.append(fractionDifferenceBiomass_rowIndex)
				colIndexes.append(fractionDifferenceBiomassOut_colIndex)
				values.append(-1)


		elif objectiveType == "pools":
			raise NotImplementedError()

		else:
			raise FBAException("Unrecognized objectiveType: {}".format(objectiveType))

		# Add internal exchange reactions

		if internalExchangedMolecules is not None:
			raise NotImplementedError()

		# Set up enzyme pseudometabolites and constraints

		# NOTE: there are two types of enzymatic constraints:
		# - rate limitations, which constrain by (turnover number)*(enzyme count)
		# - boolean limitations, which constrain by 0 (enzyme count == 0) or inf (enzyme count > 0)

		enzymeUsageRateConstrainedIndexes = []
		enzymeUsageBoolConstrainedIndexes = []

		if reactionEnzymes is not None:

			## First create the pseudometabolites and enzyme usage columns
			self._enzymeIDs = tuple(set(reactionEnzymes.values()))

			for enzymeID in self._enzymeIDs:
				# Create pseudometabolite and flux for rate-constrained
				enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)
				enzymeEquivalentRate_rowIndex = self._nodeAdd(enzymeEquivalentRateID)

				enzymeUsageRateID = self._generatedID_enzymeUsageRateConstrained.format(enzymeID)
				enzymeUsageRate_colIndex = self._edgeAdd(enzymeUsageRateID)

				rowIndexes.append(enzymeEquivalentRate_rowIndex)
				colIndexes.append(enzymeUsageRate_colIndex)
				values.append(+1)

				enzymeUsageRateConstrainedIndexes.append(enzymeUsageRate_colIndex)

				# Create pseudometabolite and flux for bool-constrained
				enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)
				enzymeEquivalentBool_rowIndex = self._nodeAdd(enzymeEquivalentBoolID)

				enzymeUsageBoolID = self._generatedID_enzymeUsageBoolConstrained.format(enzymeID)
				enzymeUsageBool_colIndex = self._edgeAdd(enzymeUsageBoolID)

				rowIndexes.append(enzymeEquivalentBool_rowIndex)
				colIndexes.append(enzymeUsageBool_colIndex)
				values.append(+1)

				enzymeUsageBoolConstrainedIndexes.append(enzymeUsageBool_colIndex)


			for reactionID, enzymeID in reactionEnzymes.viewitems():
				reaction_colIndex = self._edgeIndex(reactionID)

				if reactionRates is not None and reactionRates.has_key(reactionID):
					enzymesPerReaction = -1/reactionRates[reactionID]
					enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)
					enzymeEquivalentRate_rowIndex = self._nodeIndex(enzymeEquivalentRateID)

					rowIndexes.append(enzymeEquivalentRate_rowIndex)
					colIndexes.append(reaction_colIndex)
					values.append(enzymesPerReaction)
					

				else:
					enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)
					enzymeEquivalentBool_rowIndex = self._nodeIndex(enzymeEquivalentBoolID)

					rowIndexes.append(enzymeEquivalentBool_rowIndex)
					colIndexes.append(reaction_colIndex)
					values.append(-1)

		self._enzymeUsageRateConstrainedIndexes = np.array(enzymeUsageRateConstrainedIndexes, np.int64)
		self._enzymeUsageBoolConstrainedIndexes = np.array(enzymeUsageBoolConstrainedIndexes, np.int64)

		# Set up mass accumulation column

		if moleculeMasses is not None:
			raise NotImplementedError()

		# Finalize some running values

		self._nEdges = len(self._edgeNames)
		self._nNodes = len(self._nodeNames)

		self._outputMoleculeIDs = tuple([self._nodeNames[index] for index in outputMoleculeIndexes])

		self._outputReactionIndexes = np.array(outputReactionIndexes)

		# Create cvxopt abstractions

		# Optimization problem:
		#
		# \max_v f^T x
		# 
		# subject to
		# b = Ax
		# h >= Gx TODO: check this
		#
		# where b = 0

		## Create A matrix (stoichiometry + other things)

		self._A = cvxopt.spmatrix(values, rowIndexes, colIndexes)

		## Create objective function f

		objectiveFunction = np.zeros(self._nEdges, np.float64)

		objectiveFunction[objIndexes] = objValues

		self._f = cvxopt.matrix(-objectiveFunction) # negative, since GLPK minimizes

		# TODO: refactor initial bound setting to be more like the A matrix building
		self._lowerBound = np.zeros(self._nEdges, np.float64)
		self._upperBound = np.empty(self._nEdges, np.float64)

		self._upperBound.fill(np.inf)

		self._upperBound[self._enzymeUsageRateConstrainedIndexes] = 0
		self._upperBound[self._enzymeUsageBoolConstrainedIndexes] = 0

		self._G = cvxopt.matrix(np.concatenate(
			[np.identity(self._nEdges, np.float64), -np.identity(self._nEdges, np.float64)], axis = 0
			))

		self._b = cvxopt.matrix(np.zeros(self._nNodes, np.float64))

		## Create matrix for computing output
		self._outputCalcMatrix = -np.array(cvxopt.matrix(
			self._A[outputMoleculeIndexes, outputReactionIndexes]
			))


	def _edgeAdd(self, edgeName):
		if edgeName in self._edgeNames:
			raise AlreadyExistsException("Edge already exists: {}".format(edgeName))

		else:
			self._edgeNames.append(edgeName)
			return len(self._edgeNames) - 1


	def _edgeIndex(self, edgeName, createIfDoesNotExists = False):
		try:
			return self._edgeNames.index(edgeName)

		except ValueError:
			if createIfDoesNotExists:
				return self._edgeAdd(edgeName)

			else:
				raise DoesNotExistException("Edge does not exist: {}".format(edgeName))


	def _nodeAdd(self, nodeName):
		if nodeName in self._nodeNames:
			raise AlreadyExistsException("Node already exists: {}".format(nodeName))

		else:
			self._nodeNames.append(nodeName)
			return len(self._nodeNames) - 1


	def _nodeIndex(self, nodeName, createIfDoesNotExists = False):
		try:
			return self._nodeNames.index(nodeName)

		except ValueError:
			if createIfDoesNotExists:
				return self._nodeAdd(nodeName)

			else:
				raise DoesNotExistException("Node does not exist: {}".format(nodeName))


	# Constraint setup

	# NOTE: I've used the nonspecific term "levels" since these could be
	# mole-concentration, number-concentration, or counts, depending on the 
	# formulation of the problem.  All that matters is that initialization 
	# parameters have consistent units.

	def externalMoleculeLevelsIs(self, levels):
		levels = np.array(levels)
		if (levels < 0).any():
			raise FBAException("Negative molecule levels not allowed")

		self._lowerBound[self._externalExchangeIndexes] = -levels


	def internalMoleculeLevelsIs(self, levels):
		raise NotImplementedError()


	def enzymeIDs(self):
		return self._enzymeIDs


	def enzymeLevelsIs(self, levels):
		levels = np.array(levels)
		if (levels < 0).any():
			raise FBAException("Negative enzyme levels not allowed")

		# Rate-constrained
		self._upperBound[self._enzymeUsageRateConstrainedIndexes] = levels

		# Boolean-constrained (enzyme w/o an annotated rate)
		boolConstraint = np.zeros(levels.size, np.float64)
		boolConstraint[levels > 0] = np.inf
		self._upperBound[self._enzymeUsageBoolConstrainedIndexes] = boolConstraint


	# Evaluation

	def run(self):
		h = cvxopt.matrix(
			np.concatenate([self._upperBound, -self._lowerBound], axis = 0)
			)

		oldOptions = cvxopt.solvers.options.copy()

		cvxopt.solvers.options["LPX_K_MSGLEV"] = 0

		solution = cvxopt.solvers.lp(self._f, self._G, h, self._A, self._b, solver = "glpk")

		self._rawSolution = solution

		# TODO: raise/return flag on failed optimization

		self._edgeFluxes = np.array(self._rawSolution["x"]).flatten()


	# Output

	def outputMoleculeIDs(self):
		return self._outputMoleculeIDs


	def outputMoleculeCounts(self):
		# Must compute and return two (potentially overlapping) sets of 
		# molecule counts:
		# - internal input usage (TODO)
		# - objective output production

		return np.dot(self._outputCalcMatrix, self._edgeFluxes[self._outputReactionIndexes])


if __name__ == "__main__":
	reactionStoich = {
		"B to A":{
				"A":+1,
				"B":-1,
			},
		"AB2 to C":{
				"A":-1,
				"B":-2,
				"C":+1,
			},
		}

	externalExchangedMolecules = ["A"]

	objective = {"B":20, "C":10}

	reactionEnzymes = {
		"B to A":"enzyme 1",
		"AB2 to C":"enzyme 2",
		}

	reactionRates = {
		"AB2 to C":0.1,
		}

	reversibleReactions = ["B to A"]

	fba = FluxBalanceAnalysis(
		reactionStoich,
		externalExchangedMolecules,
		objective,
		objectiveType = "flexible",
		objectiveParameters = {
			"gamma":0.5,
			"beta":0.1,
			"leading molecule ID":"C"
			},
		reversibleReactions = reversibleReactions
		# reactionEnzymes = reactionEnzymes,
		# reactionRates = reactionRates
		)

	fba.externalMoleculeLevelsIs([10])

	# enzymeCounts = []

	# for enzymeID in fba.enzymeIDs():
	# 	if enzymeID == "enzyme 1":
	# 		enzymeCounts.append(10)
		
	# 	elif enzymeID == "enzyme 2":
	# 		enzymeCounts.append(5)

	# fba.enzymeCountsIs(enzymeCounts)

	np.set_printoptions(linewidth=200)

	fba.run()

	print fba.outputMoleculeIDs()
	print fba.outputMoleculeCounts()

	# import ipdb; ipdb.set_trace()

