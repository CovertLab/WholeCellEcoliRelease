#!/usr/bin/env python

"""
Metabolism

Metabolism sub-model. Encodes molecular simulation of microbial metabolism using flux-balance analysis.

TODO:
- move over to flexFBA
- implement metabolite pools
- enzyme-limited reactions (& fit enzyme expression)
- option to call a reduced form of metabolism (assume optimal)

@author: Derek Macklin
@organization: Covert Lab, Department of Bioengineering, Stanford University
@date: Created 4/2/2013
"""

from __future__ import division

import numpy as np

import wholecell.processes.process

from wholecell.utils.constants import REQUEST_PRIORITY_METABOLISM

class Metabolism(wholecell.processes.process.Process):
	""" Metabolism """

	_name = "Metabolism"

	# Constructor
	def __init__(self):
		super(Metabolism, self).__init__()

	# Construct object graph
	def initialize(self, sim, kb):
		super(Metabolism, self).initialize(sim, kb)

		self.fba = FluxBalanceAnalysis('arguments...')

		self.fba.externalMoleculeCountsIs('max # of molecules that can be used in a time step, defined by media/diffusion')

		self.molecules = self.bulkMoleculesView(self.fba.outputMoleculeIDs())

		self.enzymes = self.bulkMoleculesView('enzyme names')

		self.bulkMoleculeRequestPriorityIs(REQUEST_PRIORITY_METABOLISM)


	def calculateRequest(self):
		self.molecules.requestAll()


	# Calculate temporal evolution
	def evolveState(self):
		# Setup
		self.fba.internalMoleculeCountsIs(self.molecules.counts())
		self.fba.enzymeCountsIs(self.enzymes.counts())

		# Run
		self.fba.run()

		# Finalize
		self.molecules.countsIs(self.fba.outputMoleculeCounts())

		# TODO: record solution metadata, probably in a listener


# TODO: move below to a new file

# import numpy as np
import cvxopt
from collections import defaultdict

class FBAException(Exception):
	pass


class AlreadyExistsException(FBAException):
	pass


class DoesNotExistException(FBAException):
	pass


class FluxBalanceAnalysis(object):
	""" FluxBalanceAnalysis

	Solver for various FBA implementations.

	
	Required arguments:

	- reactionStoich, a dict of strings:dicts (reactionID:reaction stoich)
		Each value in the dict is a dict of molecule ID to stoichiometry pairs

	- externalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- objective, a dict of strings:floats (moleculeID:objective value)
		The meaning and usage of the objective will vary depending on the 
		formulation of FBA desired.

	
	Optional arguments (set to None for default behavior):

	- objectiveType, a string
		"standard": standard FBA objective (default)
		"flexible": flexFBA
		"pools": similar to FBA; optimizes towards desired pool concentrations

	- objectiveParameters, a dict
		Keys are specific to the FBA implementation.

	- internalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- reversibleReactions, a list of strings (reactionIDs for reversible reactions)

	- reactionEnzymes, a dict of strings:strings (reactionID:enzymeID)
	
	- reactionRates, a dict of strings:floats (reactionID:catalytic rate constant * dt)
		Used to set up the pseudo metabolites and boundary constraints needed
		for limiting reactions by enzyme counts.

	- moleculeMasses, a dict of floats (moleculeID:mass)
		Used in computing the net mass into the system.  Only needed and used 
		for moleculeIDs in externalExchangedMolecules.

	
	Caveats:
	
	There is no strict type checking, despite what the above may imply.

	During initialization, an exception will be raised if a reference is made 
	to an unutilized metabolite/enzyme/etc as described by the reaction 
	network.

	"""

	# Format strings for autogenerated IDs

	## Reverse reactions
	_generatedID_reverseReaction = "{} (reverse)"

	## Exchange fluxes
	_generatedID_externalExchange = "{} external exchange"

	## Objective
	_generatedID_moleculesToEquivalents = "molecules of {} to fractional objective equivalents"
	_generatedID_moleculeEquivalents = "fractional objective equivalent for {}"

	## Rate-constrained enzymes
	_generatedID_enzymeEquivRateConstrained = "{} equivalent (rate-constrained)"
	_generatedID_enzymeUsageRateConstrained = "{} usage (rate-constrained)"

	## Bool-constrained enzymes
	_generatedID_enzymeEquivBoolConstrained = "{} equivalent (bool-constrained)"
	_generatedID_enzymeUsageBoolConstrained = "{} usage (bool-constrained)"

	## Flex FBA
	_generatedID_fractionalDifferenceLeading = "difference between fractional objective equivalents of leading molecule and {}"
	_generatedID_fractionalDifferenceBiomass = "difference between fractional objective equivalents of {} and biomass objective"

	_generatedID_fractionsOut = "fractional objective equivalents of {} out"
	_generatedID_fractionalDifferenceLeadingOut = "difference between fractional objective equivalents of leading molecule and {} out"
	_generatedID_fractionalDifferenceBiomassOut = "difference between fractional objective equivalents of {} and biomass objective out"

	# Default values, for clarity
	_lowerBoundDefault = 0
	_upperBoundDefault = np.inf


	# Initialization

	def __init__(self, reactionStoich, externalExchangedMolecules, objective,
			objectiveType = None, objectiveParameters = None,
			internalExchangedMolecules = None, reversibleReactions = None, 
			reactionEnzymes = None, reactionRates = None, moleculeMasses = None):

		# Set up attributes

		self._nodeNames = []
		self._edgeNames = []

		# Set up running values for initialization

		## Used for creating the sparse matrix
		rowIndexes = []
		colIndexes = []
		values = []

		## Output calculations
		outputMoleculeIndexes = []
		outputReactionIndexes = []

		# Set up reversible reactions
		if reversibleReactions is not None:
			for reactionID in reversibleReactions:
				reverseReactionID = self._generatedID_reverseReaction.format(reactionID)
				
				reactionStoich[reverseReactionID] = {
					moleculeID:-stoichCoeff
					for moleculeID, stoichCoeff in reactionStoich[reactionID].viewitems()
					}

				if reactionEnzymes is not None and reactionEnzymes.has_key(reactionID):
					reactionEnzymes[reverseReactionID] = reactionEnzymes[reactionID]

				if reactionRates is not None and reactionRates.has_key(reactionID):
					reactionRates[reverseReactionID] = reactionRates[reactionID]

		# Parses reaction data
		reactionIndexes = []

		for reactionID, stoichiometry in reactionStoich.viewitems():
			colIndex = self._edgeAdd(reactionID)

			for moleculeID, stoichCoeff in stoichiometry.viewitems():
				rowIndex = self._nodeIndex(moleculeID, True)

				rowIndexes.append(rowIndex)
				colIndexes.append(colIndex)
				values.append(stoichCoeff)

			reactionIndexes.append(colIndex)

		self._reactionIndexes = np.array(reactionIndexes)

		# Add external exchange reactions

		externalExchangeIndexes = []

		for moleculeID in externalExchangedMolecules:
			exchangeID = self._generatedID_externalExchange.format(moleculeID)

			colIndex = self._edgeAdd(exchangeID)
			rowIndex = self._nodeIndex(moleculeID)

			# NOTE: The convention, if I am not mistaken, is to define 
			# exchanges as pointing out of the system, even though it is common
			# to think of exchanges as inputs.  Regardless this choice should 
			# have no impact outside of this class.

			rowIndexes.append(rowIndex)
			colIndexes.append(colIndex)
			values.append(-1)

			externalExchangeIndexes.append(colIndex)

		self._externalExchangeIndexes = np.array(externalExchangeIndexes)

		# Set up the objective

		## First, set up the molecule count -> objective equivalents flux

		objectiveEquivalentIndexes = []

		for moleculeID, coeff in objective.viewitems():
			if coeff < 0:
				raise FBAException("Negative coefficients in the objective not permitted ({}, {})".format(moleculeID, coeff))

			molecule_rowIndex = self._nodeIndex(moleculeID)

			pseudoFluxID = self._generatedID_moleculesToEquivalents.format(moleculeID)
			colIndex = self._edgeAdd(pseudoFluxID)

			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)
			objectiveEquiv_rowIndex = self._nodeAdd(objectiveEquivID)

			rowIndexes.append(molecule_rowIndex)
			colIndexes.append(colIndex)
			values.append(-coeff)

			rowIndexes.append(objectiveEquiv_rowIndex)
			colIndexes.append(colIndex)
			values.append(+1)

			outputMoleculeIndexes.append(molecule_rowIndex)
			objectiveEquivalentIndexes.append(objectiveEquiv_rowIndex)

			outputReactionIndexes.append(colIndex)

		## Next, set up the actual objective function (implementation varies)
		objIndexes = []
		objValues = []

		lowerBoundIndexes = []
		lowerBoundValues = []

		upperBoundIndexes = []
		upperBoundValues = []

		if objectiveType is None or objectiveType == "standard":
			objectiveID = "Standard FBA objective reaction"

			colIndex = self._edgeAdd(objectiveID)

			nObjectiveEquivalents = len(objectiveEquivalentIndexes)

			rowIndexes.extend(objectiveEquivalentIndexes)
			colIndexes.extend([colIndex]*nObjectiveEquivalents)
			values.extend([-1]*nObjectiveEquivalents)

			objIndexes.append(colIndex)
			objValues.append(+1)

		elif objectiveType == "flexible":
			# Load parameters
			leadingMoleculeID = objectiveParameters["leading molecule ID"]

			if not objective.has_key(leadingMoleculeID):
				raise FBAException("flexFBA leading molecule must be in the objective")

			fractionalDifferenceWeight = objectiveParameters["gamma"]

			if fractionalDifferenceWeight < 0:
				raise FBAException("flexFBA gamma paramter must be nonnegative")

			biomassSatisfactionWeight = objectiveParameters["beta"]

			if biomassSatisfactionWeight < 0:
				raise FBAException("flexFBA beta paramter must be nonnegative")

			biomass_colIndex = self._edgeAdd("Standard biomass objective")

			# Add biomass to objective
			objIndexes.append(biomass_colIndex)
			objValues.append(biomassSatisfactionWeight)

			# Create fraction and biomass outputs
			for moleculeID in objective.viewkeys():
				fractionID = self._generatedID_moleculeEquivalents.format(moleculeID)
				fraction_rowIndex = self._nodeIndex(fractionID)

				# Biomass out
				rowIndexes.append(fraction_rowIndex)
				colIndexes.append(biomass_colIndex)
				values.append(-1)

				# Fraction out
				fractionOutID = self._generatedID_fractionsOut.format(moleculeID)
				fractionOut_colIndex = self._edgeAdd(fractionOutID)

				rowIndexes.append(fraction_rowIndex)
				colIndexes.append(fractionOut_colIndex)
				values.append(-1)

				if moleculeID == leadingMoleculeID:
					# Add leading molecule to objective
					objIndexes.append(fractionOut_colIndex)
					objValues.append(+1)

			# Create fraction differences (leading - other), used in objective and constraints
			leadingMoleculeToFractionID = self._generatedID_moleculesToEquivalents.format(leadingMoleculeID)
			leadingMoleculeToFraction_colIndex = self._edgeIndex(leadingMoleculeToFractionID)

			for moleculeID in objective.viewkeys():
				if moleculeID == leadingMoleculeID:
					continue

				fractionDifferenceLeadingID = self._generatedID_fractionalDifferenceLeading.format(moleculeID)
				fractionDifferenceLeading_rowIndex = self._nodeAdd(fractionDifferenceLeadingID)

				rowIndexes.append(fractionDifferenceLeading_rowIndex)
				colIndexes.append(leadingMoleculeToFraction_colIndex)
				values.append(+1)
				
				moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)
				moleculeToFraction_colIndex = self._edgeIndex(moleculeToFractionID)

				rowIndexes.append(fractionDifferenceLeading_rowIndex)
				colIndexes.append(moleculeToFraction_colIndex)
				values.append(-1)

				fractionDifferenceLeadingOutID = self._generatedID_fractionalDifferenceLeadingOut.format(moleculeID)
				fractionDifferenceLeadingOut_colIndex = self._edgeAdd(fractionDifferenceLeadingOutID)

				rowIndexes.append(fractionDifferenceLeading_rowIndex)
				colIndexes.append(fractionDifferenceLeadingOut_colIndex)
				values.append(-1)

				objIndexes.append(fractionDifferenceLeadingOut_colIndex)
				objValues.append(-fractionalDifferenceWeight)

			# Create biomass differences (fraction - biomass), used in constraints

			for moleculeID in objective.viewkeys():
				fractionDifferenceBiomassID = self._generatedID_fractionalDifferenceBiomass.format(moleculeID)
				fractionDifferenceBiomass_rowIndex = self._nodeAdd(fractionDifferenceBiomassID)

				moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)
				moleculeToFraction_colIndex = self._edgeIndex(moleculeToFractionID)

				rowIndexes.append(fractionDifferenceBiomass_rowIndex)
				colIndexes.append(moleculeToFraction_colIndex)
				values.append(+1)

				rowIndexes.append(fractionDifferenceBiomass_rowIndex)
				colIndexes.append(biomass_colIndex)
				values.append(-1)

				fractionDifferenceBiomassOutID = self._generatedID_fractionalDifferenceBiomassOut.format(moleculeID)
				fractionDifferenceBiomassOut_colIndex = self._edgeAdd(fractionDifferenceBiomassOutID)

				rowIndexes.append(fractionDifferenceBiomass_rowIndex)
				colIndexes.append(fractionDifferenceBiomassOut_colIndex)
				values.append(-1)


		elif objectiveType == "pools":
			raise NotImplementedError()

		else:
			raise FBAException("Unrecognized objectiveType: {}".format(objectiveType))

		# Add internal exchange reactions

		if internalExchangedMolecules is not None:
			raise NotImplementedError()

		# Set up enzyme pseudometabolites and constraints

		# NOTE: there are two types of enzymatic constraints:
		# - rate limitations, which constrain by (turnover number)*(enzyme count)
		# - boolean limitations, which constrain by 0 (enzyme count == 0) or inf (enzyme count > 0)

		enzymeUsageRateConstrainedIndexes = []
		enzymeUsageBoolConstrainedIndexes = []

		if reactionEnzymes is not None:

			## First create the pseudometabolites and enzyme usage columns
			self._enzymeIDs = tuple(set(reactionEnzymes.values()))

			for enzymeID in self._enzymeIDs:
				# Create pseudometabolite and flux for rate-constrained
				enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)
				enzymeEquivalentRate_rowIndex = self._nodeAdd(enzymeEquivalentRateID)

				enzymeUsageRateID = self._generatedID_enzymeUsageRateConstrained.format(enzymeID)
				enzymeUsageRate_colIndex = self._edgeAdd(enzymeUsageRateID)

				rowIndexes.append(enzymeEquivalentRate_rowIndex)
				colIndexes.append(enzymeUsageRate_colIndex)
				values.append(+1)

				enzymeUsageRateConstrainedIndexes.append(enzymeUsageRate_colIndex)

				# Create pseudometabolite and flux for bool-constrained
				enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)
				enzymeEquivalentBool_rowIndex = self._nodeAdd(enzymeEquivalentBoolID)

				enzymeUsageBoolID = self._generatedID_enzymeUsageBoolConstrained.format(enzymeID)
				enzymeUsageBool_colIndex = self._edgeAdd(enzymeUsageBoolID)

				rowIndexes.append(enzymeEquivalentBool_rowIndex)
				colIndexes.append(enzymeUsageBool_colIndex)
				values.append(+1)

				enzymeUsageBoolConstrainedIndexes.append(enzymeUsageBool_colIndex)


			for reactionID, enzymeID in reactionEnzymes.viewitems():
				reaction_colIndex = self._edgeIndex(reactionID)

				if reactionRates is not None and reactionRates.has_key(reactionID):
					reactionRate = reactionRates[reactionID]

					if reactionRate <= 0:
						raise FBAException("Reaction rates must be positive ({}, {})".format(reactionID, reactionRate))

					enzymesPerReaction = -1/reactionRate
					enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)
					enzymeEquivalentRate_rowIndex = self._nodeIndex(enzymeEquivalentRateID)

					rowIndexes.append(enzymeEquivalentRate_rowIndex)
					colIndexes.append(reaction_colIndex)
					values.append(enzymesPerReaction)
					

				else:
					enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)
					enzymeEquivalentBool_rowIndex = self._nodeIndex(enzymeEquivalentBoolID)

					rowIndexes.append(enzymeEquivalentBool_rowIndex)
					colIndexes.append(reaction_colIndex)
					values.append(-1)

		self._enzymeUsageRateConstrainedIndexes = np.array(enzymeUsageRateConstrainedIndexes, np.int64)
		self._enzymeUsageBoolConstrainedIndexes = np.array(enzymeUsageBoolConstrainedIndexes, np.int64)

		# Set up mass accumulation column

		if moleculeMasses is not None:
			raise NotImplementedError()

		# Finalize some running values

		self._nEdges = len(self._edgeNames)
		self._nNodes = len(self._nodeNames)

		self._outputMoleculeIDs = tuple([self._nodeNames[index] for index in outputMoleculeIndexes])

		self._outputReactionIndexes = np.array(outputReactionIndexes)

		# Create cvxopt abstractions

		# Optimization problem:
		#
		# \max_v f^T x
		# 
		# subject to
		# b = Ax
		# h >= Gx TODO: check this
		#
		# where b = 0

		## Create A matrix (stoichiometry + other things)

		self._A = cvxopt.spmatrix(values, rowIndexes, colIndexes)

		## Create objective function f

		objectiveFunction = np.zeros(self._nEdges, np.float64)

		objectiveFunction[objIndexes] = objValues

		self._f = cvxopt.matrix(-objectiveFunction) # negative, since GLPK minimizes

		# TODO: refactor initial bound setting to be more like the A matrix building
		self._lowerBound = np.empty(self._nEdges, np.float64)
		self._lowerBound.fill(self._lowerBoundDefault)
		self._lowerBound[lowerBoundIndexes] = lowerBoundValues

		self._upperBound = np.empty(self._nEdges, np.float64)
		self._upperBound.fill(self._upperBoundDefault)
		self._upperBound[upperBoundIndexes] = upperBoundValues

		self._G = cvxopt.matrix(np.concatenate(
			[np.identity(self._nEdges, np.float64), -np.identity(self._nEdges, np.float64)], axis = 0
			))

		self._b = cvxopt.matrix(np.zeros(self._nNodes, np.float64))

		## Create matrix for computing output
		self._outputCalcMatrix = -np.array(cvxopt.matrix(
			self._A[outputMoleculeIndexes, outputReactionIndexes]
			))

		# Set up values that will change between runs

		self.externalMoleculeLevelsIs(0)
		# self.internalMoleculeLevelsIs(0)
		self.enzymeLevelsIs(0)


	def _edgeAdd(self, edgeName):
		if edgeName in self._edgeNames:
			raise AlreadyExistsException("Edge already exists: {}".format(edgeName))

		else:
			self._edgeNames.append(edgeName)
			return len(self._edgeNames) - 1


	def _edgeIndex(self, edgeName, createIfDoesNotExists = False):
		try:
			return self._edgeNames.index(edgeName)

		except ValueError:
			if createIfDoesNotExists:
				return self._edgeAdd(edgeName)

			else:
				raise DoesNotExistException("Edge does not exist: {}".format(edgeName))


	def _nodeAdd(self, nodeName):
		if nodeName in self._nodeNames:
			raise AlreadyExistsException("Node already exists: {}".format(nodeName))

		else:
			self._nodeNames.append(nodeName)
			return len(self._nodeNames) - 1


	def _nodeIndex(self, nodeName, createIfDoesNotExists = False):
		try:
			return self._nodeNames.index(nodeName)

		except ValueError:
			if createIfDoesNotExists:
				return self._nodeAdd(nodeName)

			else:
				raise DoesNotExistException("Node does not exist: {}".format(nodeName))


	# Constraint setup

	# NOTE: I've used the nonspecific term "levels" since these could be
	# mole-concentration, number-concentration, or counts, depending on the 
	# formulation of the problem.  All that matters is that initialization 
	# parameters have consistent units.

	def externalMoleculeLevelsIs(self, levels):
		levels = np.array(levels)
		if (levels < 0).any():
			raise FBAException("Negative molecule levels not allowed")

		self._lowerBound[self._externalExchangeIndexes] = -levels


	def internalMoleculeLevelsIs(self, levels):
		raise NotImplementedError()


	def enzymeIDs(self):
		return self._enzymeIDs


	def enzymeLevelsIs(self, levels):
		levels = np.array(levels)
		if (levels < 0).any():
			raise FBAException("Negative enzyme levels not allowed")

		# Rate-constrained
		self._upperBound[self._enzymeUsageRateConstrainedIndexes] = levels

		# Boolean-constrained (enzyme w/o an annotated rate)
		boolConstraint = np.zeros(levels.size, np.float64)
		boolConstraint[levels > 0] = np.inf
		self._upperBound[self._enzymeUsageBoolConstrainedIndexes] = boolConstraint


	# Evaluation

	def run(self):
		h = cvxopt.matrix(
			np.concatenate([self._upperBound, -self._lowerBound], axis = 0)
			)

		oldOptions = cvxopt.solvers.options.copy()

		cvxopt.solvers.options["LPX_K_MSGLEV"] = 0

		solution = cvxopt.solvers.lp(self._f, self._G, h, self._A, self._b, solver = "glpk")

		self._rawSolution = solution

		# TODO: raise/return flag on failed optimization

		self._edgeFluxes = np.array(self._rawSolution["x"]).flatten()


	# Output

	def outputMoleculeIDs(self):
		return self._outputMoleculeIDs


	def outputMoleculeCounts(self):
		# Must compute and return two (potentially overlapping) sets of 
		# molecule counts:
		# - internal input usage (TODO)
		# - objective output production

		return np.dot(self._outputCalcMatrix, self._edgeFluxes[self._outputReactionIndexes])


if __name__ == "__main__":
	from wholecell.reconstruction.knowledge_base_ecoli import KnowledgeBaseEcoli
	kb = KnowledgeBaseEcoli()

	objectiveRaw = {
		'10fthf[c]' : -0.000223,
		'2ohph[c]' : -0.000223,
		'adp[c]' : 59.810000000000002,
		'ala-L[c]' : -0.51370000000000005,
		'amet[c]' : -0.000223,
		'arg-L[c]' : -0.29580000000000001,
		'asn-L[c]' : -0.24110000000000001,
		'asp-L[c]' : -0.24110000000000001,
		'atp[c]' : -59.984000000000002,
		'ca2[c]' : -0.0047369999999999999,
		'cl[c]' : -0.0047369999999999999,
		'coa[c]' : -0.00057600000000000001,
		'cobalt2[c]' : -0.0031580000000000002,
		'ctp[c]' : -0.13350000000000001,
		'cu2[c]' : -0.0031580000000000002,
		'cys-L[c]' : -0.091579999999999995,
		'datp[c]' : -0.026169999999999999,
		'dctp[c]' : -0.027019999999999999,
		'dgtp[c]' : -0.027019999999999999,
		'dttp[c]' : -0.026169999999999999,
		'fad[c]' : -0.000223,
		'fe2[c]' : -0.0071060000000000003,
		'fe3[c]' : -0.0071060000000000003,
		'gln-L[c]' : -0.26319999999999999,
		'glu-L[c]' : -0.26319999999999999,
		'gly[c]' : -0.61260000000000003,
		'gtp[c]' : -0.21510000000000001,
		'h2o[c]' : -54.462000000000003,
		'h[c]' : 59.810000000000002,
		'his-L[c]' : -0.094740000000000005,
		'ile-L[c]' : -0.29049999999999998,
		'k[c]' : -0.17760000000000001,
		'kdo2lipid4[e]' : -0.019449999999999999,
		'leu-L[c]' : -0.45050000000000001,
		'lys-L[c]' : -0.34320000000000001,
		'met-L[c]' : -0.1537,
		'mg2[c]' : -0.0078949999999999992,
		'mlthf[c]' : -0.000223,
		'mn2[c]' : -0.0031580000000000002,
		'mobd[c]' : -0.0031580000000000002,
		'murein5px4p[p]' : -0.01389,
		'nad[c]' : -0.0018309999999999999,
		'nadp[c]' : -0.00044700000000000002,
		'nh4[c]' : -0.011842999999999999,
		'pe160[c]' : -0.022329999999999999,
		'pe160[p]' : -0.041480000000000003,
		'pe161[c]' : -0.02632,
		'pe161[p]' : -0.048890000000000003,
		'phe-L[c]' : -0.1759,
		'pheme[c]' : -0.000223,
		'pi[c]' : 59.805999999999997,
		'ppi[c]' : 0.77390000000000003,
		'pro-L[c]' : -0.22109999999999999,
		'pydx5p[c]' : -0.000223,
		'ribflv[c]' : -0.000223,
		'ser-L[c]' : -0.21579999999999999,
		'sheme[c]' : -0.000223,
		'so4[c]' : -0.0039480000000000001,
		'thf[c]' : -0.000223,
		'thmpp[c]' : -0.000223,
		'thr-L[c]' : -0.25369999999999998,
		'trp-L[c]' : -0.056840000000000002,
		'tyr-L[c]' : -0.13789999999999999,
		'udcpdp[c]' : -5.5000000000000002e-05,
		'utp[c]' : -0.14410000000000001,
		'val-L[c]' : -0.42320000000000002,
		'zn2[c]' : -0.0031580000000000002,
		}

	objective = {}
	internalMoleculeLevels = {}
	for moleculeID_raw, coeff in objectiveRaw.viewitems():
		moleculeID = moleculeID_raw[:-2].upper() + moleculeID_raw[-2:]

		if moleculeID == "KDO2LIPID4[e]":
			moleculeID = "KDO2LIPID4[o]"

		if coeff < 0:
			objective[moleculeID] = -coeff

		else:
			internalMoleculeLevels[moleculeID] = coeff

	import re
	rxns = [x for x in kb.metabolismBiochemicalReactions if not re.match(".*_[0-9]$", x["id"]) or x["id"].endswith("_0") or "PFK_2" in x["id"]]

	reactionStoich = {
		rxn["id"]:
		{entry["molecule"]+"["+entry["location"]+"]":entry["coeff"] for entry in rxn["stoichiometry"]}
		for rxn in rxns
		if len(rxn["stoichiometry"]) > 1 # no exchange reactions!
		}

	reversibleReactions = [rxn["id"] for rxn in rxns if not rxn["dir"]]

	mediaEx = kb.metabolismMediaEx

	externalExchangedMolecules = [rxn["met"] for rxn in mediaEx]

	atpId = "ATP[c]"

	fba = FluxBalanceAnalysis(
		reactionStoich,
		externalExchangedMolecules,
		objective,
		objectiveType = "flexible",
		objectiveParameters = {
			"gamma":0.1,
			"beta":100,
			"leading molecule ID":atpId
			},
		reversibleReactions = reversibleReactions
		# reactionEnzymes = reactionEnzymes,
		# reactionRates = reactionRates
		)

	fba.run()

	print fba.outputMoleculeIDs()
	print fba.outputMoleculeCounts()

	# import ipdb; ipdb.set_trace()

# biomass = [{'coeff': -0.000223, 'id': '10fthf[c]'}, {'coeff': -0.000223, 'id': '2ohph[c]'}, {'coeff': 59.810000000000002, 'id': 'adp[c]'}, {'coeff': -0.51370000000000005, 'id': 'ala-L[c]'}, {'coeff': -0.000223, 'id': 'amet[c]'}, {'coeff': -0.29580000000000001, 'id': 'arg-L[c]'}, {'coeff': -0.24110000000000001, 'id': 'asn-L[c]'}, {'coeff': -0.24110000000000001, 'id': 'asp-L[c]'}, {'coeff': -59.984000000000002, 'id': 'atp[c]'}, {'coeff': -0.0047369999999999999, 'id': 'ca2[c]'}, {'coeff': -0.0047369999999999999, 'id': 'cl[c]'}, {'coeff': -0.00057600000000000001, 'id': 'coa[c]'}, {'coeff': -0.0031580000000000002, 'id': 'cobalt2[c]'}, {'coeff': -0.13350000000000001, 'id': 'ctp[c]'}, {'coeff': -0.0031580000000000002, 'id': 'cu2[c]'}, {'coeff': -0.091579999999999995, 'id': 'cys-L[c]'}, {'coeff': -0.026169999999999999, 'id': 'datp[c]'}, {'coeff': -0.027019999999999999, 'id': 'dctp[c]'}, {'coeff': -0.027019999999999999, 'id': 'dgtp[c]'}, {'coeff': -0.026169999999999999, 'id': 'dttp[c]'}, {'coeff': -0.000223, 'id': 'fad[c]'}, {'coeff': -0.0071060000000000003, 'id': 'fe2[c]'}, {'coeff': -0.0071060000000000003, 'id': 'fe3[c]'}, {'coeff': -0.26319999999999999, 'id': 'gln-L[c]'}, {'coeff': -0.26319999999999999, 'id': 'glu-L[c]'}, {'coeff': -0.61260000000000003, 'id': 'gly[c]'}, {'coeff': -0.21510000000000001, 'id': 'gtp[c]'}, {'coeff': -54.462000000000003, 'id': 'h2o[c]'}, {'coeff': 59.810000000000002, 'id': 'h[c]'}, {'coeff': -0.094740000000000005, 'id': 'his-L[c]'}, {'coeff': -0.29049999999999998, 'id': 'ile-L[c]'}, {'coeff': -0.17760000000000001, 'id': 'k[c]'}, {'coeff': -0.019449999999999999, 'id': 'kdo2lipid4[e]'}, {'coeff': -0.45050000000000001, 'id': 'leu-L[c]'}, {'coeff': -0.34320000000000001, 'id': 'lys-L[c]'}, {'coeff': -0.1537, 'id': 'met-L[c]'}, {'coeff': -0.0078949999999999992, 'id': 'mg2[c]'}, {'coeff': -0.000223, 'id': 'mlthf[c]'}, {'coeff': -0.0031580000000000002, 'id': 'mn2[c]'}, {'coeff': -0.0031580000000000002, 'id': 'mobd[c]'}, {'coeff': -0.01389, 'id': 'murein5px4p[p]'}, {'coeff': -0.0018309999999999999, 'id': 'nad[c]'}, {'coeff': -0.00044700000000000002, 'id': 'nadp[c]'}, {'coeff': -0.011842999999999999, 'id': 'nh4[c]'}, {'coeff': -0.022329999999999999, 'id': 'pe160[c]'}, {'coeff': -0.041480000000000003, 'id': 'pe160[p]'}, {'coeff': -0.02632, 'id': 'pe161[c]'}, {'coeff': -0.048890000000000003, 'id': 'pe161[p]'}, {'coeff': -0.1759, 'id': 'phe-L[c]'}, {'coeff': -0.000223, 'id': 'pheme[c]'}, {'coeff': 59.805999999999997, 'id': 'pi[c]'}, {'coeff': 0.77390000000000003, 'id': 'ppi[c]'}, {'coeff': -0.22109999999999999, 'id': 'pro-L[c]'}, {'coeff': -0.000223, 'id': 'pydx5p[c]'}, {'coeff': -0.000223, 'id': 'ribflv[c]'}, {'coeff': -0.21579999999999999, 'id': 'ser-L[c]'}, {'coeff': -0.000223, 'id': 'sheme[c]'}, {'coeff': -0.0039480000000000001, 'id': 'so4[c]'}, {'coeff': -0.000223, 'id': 'thf[c]'}, {'coeff': -0.000223, 'id': 'thmpp[c]'}, {'coeff': -0.25369999999999998, 'id': 'thr-L[c]'}, {'coeff': -0.056840000000000002, 'id': 'trp-L[c]'}, {'coeff': -0.13789999999999999, 'id': 'tyr-L[c]'}, {'coeff': -5.5000000000000002e-05, 'id': 'udcpdp[c]'}, {'coeff': -0.14410000000000001, 'id': 'utp[c]'}, {'coeff': -0.42320000000000002, 'id': 'val-L[c]'}, {'coeff': -0.0031580000000000002, 'id': 'zn2[c]'}]
# for x in biomass:
# 	x["id"] = x["id"][:-2].upper() + x["id"][-2:]
# 	if x["id"] == "KDO2LIPID4[e]":
# 		x["id"] = "KDO2LIPID4[o]"


# metIds = [x for x in kb.metabolismMoleculeNames]
# import re
# rxns = [x for x in kb.metabolismBiochemicalReactions if not re.match(".*_[0-9]$", x["id"]) or x["id"].endswith("_0") or "PFK_2" in x["id"]]
# rxnIsIrreversible = np.array([x["dir"] for x in rxns], dtype = np.bool)
# mediaEx = kb.metabolismMediaEx
# # biomass = [{"id": x["metaboliteId"], "coeff": -x["biomassFlux"]} for x in kb.wildtypeBiomass.struct_array]
# atpId = "ATP[c]"
# # self.flexTFbaModel = wholecell.utils.flex_t_fba_model.FlexTFbaModel(metIds = metIds, rxns = rxns, mediaEx = mediaEx, biomass = biomass, atpId = "ATP[c]", params = None)
# self.flexTFbaModel = wholecell.utils.d_fba_model.dFbaModel(metIds = metIds, rxns = rxns, mediaEx = mediaEx, biomass = biomass)
# self.lb = wholecell.utils.flex_t_fba_model.bounds(["thermodynamic", "exchange", "bs"], self.flexTFbaModel.rxnIds(), False)
# self.ub = wholecell.utils.flex_t_fba_model.bounds(["thermodynamic", "exchange", "bs"], self.flexTFbaModel.rxnIds(), True)

# # Thermodynamic bounds
# self.lb.valuesIs(self.flexTFbaModel.rxnGroup("real").idxs()[rxnIsIrreversible], "thermodynamic", 0)

# # Biomass return is zero (for testing)
# # self.lb.valuesIs(self.flexTFbaModel.rxnGroup("x").idxs(), "exchange", 0)

# # Media exchange
# self.lb.valuesIs(self.flexTFbaModel.rxnGroup("mediaEx").idxs(), "exchange", 0)
# mediaRxnIds = [
# 	"mediaEx_FEIST_EX_ca2(e)",
# 	"mediaEx_FEIST_EX_cl(e)",
# 	"mediaEx_FEIST_EX_co2(e)",
# 	"mediaEx_FEIST_EX_cobalt2(e)",
# 	"mediaEx_FEIST_EX_cu2(e)",
# 	"mediaEx_FEIST_EX_fe2(e)",
# 	"mediaEx_FEIST_EX_fe3(e)",
# 	"mediaEx_FEIST_EX_h(e)",
# 	"mediaEx_FEIST_EX_h2o(e)",
# 	"mediaEx_FEIST_EX_k(e)",
# 	"mediaEx_FEIST_EX_mg2(e)",
# 	"mediaEx_FEIST_EX_mn2(e)",
# 	"mediaEx_FEIST_EX_mobd(e)",
# 	"mediaEx_FEIST_EX_na1(e)",
# 	"mediaEx_FEIST_EX_nh4(e)",
# 	"mediaEx_FEIST_EX_pi(e)",
# 	"mediaEx_FEIST_EX_so4(e)",
# 	"mediaEx_FEIST_EX_tungs(e)",
# 	"mediaEx_FEIST_EX_zn2(e)",
# 	# "mediaEx_FEIST_EX_cbl1(e)",
# 	# "mediaEx_SELNP_MEDIA_EXCHANGE_HACKED",
# 	]
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(mediaRxnIds), "exchange", -np.inf)
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["mediaEx_FEIST_EX_cbl1(e)"]), "exchange", -0.01)

# # Nutrient limitations
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["mediaEx_FEIST_EX_glc(e)"]), "exchange", -8.)
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["mediaEx_FEIST_EX_o2(e)"]), "exchange", -18.5)
# # self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["mediaEx_FEIST_EX_glc(e)"]), "exchange", -100.)
# # self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["mediaEx_FEIST_EX_o2(e)"]), "exchange", -100)

# # ATPM
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_ATPM"]), "bs", 8.39)
# self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_ATPM"]), "bs", 8.39)

# # Reactions Feist arbitrarily set to 0
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_CAT_0"]), "bs", 0)
# self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_CAT_0"]), "bs", 0)
# # self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_CAT_1"]), "bs", 0)
# # self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_CAT_1"]), "bs", 0)
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_SPODM_0"]), "bs", 0)
# self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_SPODM_0"]), "bs", 0)
# # self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_SPODM_1"]), "bs", 0)
# # self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_SPODM_1"]), "bs", 0)
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_SPODMpp"]), "bs", 0)
# self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_SPODMpp"]), "bs", 0)
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_0_0"]), "bs", 0)
# self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_0_0"]), "bs", 0)
# # self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_0_1"]), "bs", 0)
# # self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_0_1"]), "bs", 0)
# self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_1_0"]), "bs", 0)
# self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_1_0"]), "bs", 0)
# # self.lb.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_1_1"]), "bs", 0)
# # self.ub.valuesIs(self.flexTFbaModel.rxnIdxs(["rxn_FEIST_FHL_1_1"]), "bs", 0)

# self.flexTFbaModel.v_lowerIs(idxs = self.flexTFbaModel.rxnGroup("lowerMutable").idxs(), values = self.lb.mergedValues(self.flexTFbaModel.rxnGroup("lowerMutable").idxs()))
# self.flexTFbaModel.v_upperIs(idxs = self.flexTFbaModel.rxnGroup("upperMutable").idxs(), values = self.ub.mergedValues(self.flexTFbaModel.rxnGroup("upperMutable").idxs()))

# self.flexTFbaModel.solution()[self.flexTFbaModel.rxnIdxs(["mediaEx_FEIST_EX_glc(e)"])]
# self.flexTFbaModel.solution()[self.flexTFbaModel.rxnIdxs(["mediaEx_FEIST_EX_o2(e)"])]
# self.flexTFbaModel.solution()[self.flexTFbaModel.rxnIdxs(["g_bio"])]
