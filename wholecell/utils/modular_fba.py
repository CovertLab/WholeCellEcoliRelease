#!/usr/bin/env python

"""
@author: John Mason
@organization: Covert Lab, Department of Bioengineering, Stanford University
@date: Created 7/14/2014
"""

from __future__ import division

from collections import defaultdict
from itertools import izip
import warnings

import numpy as np

NUMERICAL_ZERO = 1e-20

SOLVERS = {}
S_GUROBI = "gurobi"
S_GLPK = "glpk"
_SOLVER_PREFERENCE = (
	S_GLPK,
	S_GUROBI
	)

try:
	from ._netflow.nf_gurobi import NetworkFlowGurobi

except ImportError:
	pass

except Exception as e:
	# If this is a GurobiError, proceed without using gurobi, warning the user.
	if str(type(e)) == "<class 'gurobipy.GurobiError'>":
		print "GurobiError - gurobi will not be used."
	# Otherwise, raise the exception as normal
	else:
		raise e

else:
	SOLVERS[S_GUROBI] = NetworkFlowGurobi

try:
	from ._netflow.nf_glpk import NetworkFlowGLPK

except ImportError:
	pass

else:
	SOLVERS[S_GLPK] = NetworkFlowGLPK

if not SOLVERS:
	raise Exception("No solvers available.")

for solver in _SOLVER_PREFERENCE:
	if solver in SOLVERS:
		DEFAULT_SOLVER = solver
		break

else:
	raise Exception("Could not choose a default solver.")

# Errors

class FBAError(Exception):
	pass


class AlreadyExistsError(FBAError):
	pass


class DoesNotExistError(FBAError):
	pass


class InvalidBoundaryError(FBAError):
	pass


class SolverUnavailableError(FBAError):
	pass

# Classes


class FluxBalanceAnalysis(object):
	""" FluxBalanceAnalysis
	Solver for various FBA implementations.
	Required arguments:
	- reactionStoich, a dict of strings:dicts (reactionID:reaction stoich)
		Each value in the dict is a dict of molecule ID to stoichiometry pairs
	- externalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.
	- objective, a dict of strings:floats (moleculeID:objective value)
		The meaning and usage of the objective will vary depending on the
		formulation of FBA desired.
	Optional arguments (set to None for default behavior):
	- objectiveType, a string
		"standard": standard FBA objective (default)
		"flexible": flexFBA
		"homeostatic": similar to FBA; optimizes towards desired homeostatic concentrations
		"range_homeostatic": homeostatic FBA with the option to allow a range of desired homeostatic concentrations
		"kinetic_only":  optimize to minimize deviation from reaction flux through given kinetic reaction flux targets
		"homeostatic_kinetics_mixed":  A split objective, both range_homeostatic and kinetic, optimizing to minimize deviation
									   from homeostatic concentrations for a set of molecules, and a set of kinetic rates for a
									   set of reaction fluxes.
	- objectiveParameters, a dict
		Keys are specific to the FBA implementation.
	- internalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.
	- reversibleReactions, a list of strings (reactionIDs for reversible reactions)
	- moleculeMasses, a dict of floats (moleculeID:mass)
		Used in computing the net mass into the system.  Only needed and used
		for moleculeIDs in externalExchangedMolecules.
	Caveats:
	There is no strict type checking, despite what the above may imply.
	During initialization, an exception will be raised if a reference is made
	to an unutilized metabolite etc as described by the reaction
	network.
	"""

	# Format strings for autogenerated IDs

	## Reverse reactions
	_generatedID_reverseReaction = "{} (reverse)"

	## Exchange fluxes
	_generatedID_externalExchange = "{} external exchange"
	_generatedID_internalExchange = "{} internal exchange"

	_generatedID_externalExchangePos = "{} external exchange pos"
	_generatedID_externalExchangeNeg = "{} external exchange neg"
	_generatedID_externalExchangeAbs = "{} external exchange abs"

	## Objective
	_generatedID_moleculesToEquivalents = "molecules of {} to fractional objective equivalents"
	_generatedID_moleculeEquivalents = "fractional objective equivalent for molecules of {}"

	## Flex FBA
	_generatedID_fractionalDifferenceLeading = "difference between fractional objective equivalents of leading molecule and {}"
	_generatedID_fractionalDifferenceBiomass = "difference between fractional objective equivalents of {} and biomass objective"

	_generatedID_fractionsOut = "fractional objective equivalents of {} out"
	_generatedID_fractionalDifferenceLeadingOut = "difference between fractional objective equivalents of leading molecule and {} out"
	_generatedID_fractionalDifferenceBiomassOut = "difference between fractional objective equivalents of {} and biomass objective out"

	## Homeostatic FBA
	_generatedID_fractionBelowUnityOut = "fraction {} below unity, out"
	_generatedID_fractionAboveUnityOut = "fraction {} above unity, out"

	_standardObjectiveReactionName = "Standard biomass objective reaction"

	_massExchangeID = "Mass Exchange"
	_massExchangeOutName = "Mass exchange out"

	_forcedUnityColName = "Column forced at unity"

	_pseudometaboliteGAM = "GAM reaction pseudometabolite"
	_reactionID_GAM = "Growth-associated maintenance reaction"
	_reactionID_NGAM = "Non-growth-associated maintenance reaction"
	_reactionID_polypeptideElongationEnergy = "PolypeptideElongation energy reaction"

	## Range Homeostatic FBA
	_generatedID_fractionInRangeOut = "fraction {} within target range, out"

	## MOMA
	_generatedID_amountOver = "Amount {} flux is over target"
	_generatedID_amountUnder = "Amount {} flux is under target"

	_generatedID_kineticReactionEquivalentsPseudoflux = "pseudoflux to remove kinetic objective equivalents for reaction {}"
	_generatedID_kineticReactionEquivalents = "kinetic reaction objective equivalent for {} reaction"

	## Kinetic
	_generatedID_reactionFluxEquivalents = "reaction flux equivalent for {} reaction"
	_generatedID_conversionFlux = "Flux converting {} flux to kinetic objective equivalents"


	# Default values, for clarity
	_lowerBoundDefault = 0
	_upperBoundDefault = np.inf

	# Initialization

	def __init__(self, reactionStoich, externalExchangedMolecules, objective,
			objectiveType = None, objectiveParameters = None,
			internalExchangedMolecules = None,
			secretionPenaltyCoeff = None,
			moleculeMasses = None, maintenanceCostGAM = None,
			maintenanceReaction = None,
			solver = DEFAULT_SOLVER):

		if solver not in SOLVERS:
			raise SolverUnavailableError(
				"Unrecognized or unavailable solver: {}".format(solver)
				)

		self.objectiveType = objectiveType

		if objectiveType is None:
			self.objectiveType = "standard"

		self._solver = SOLVERS[solver]()

		self._forceInternalExchange = False

		# Output calculations
		self._outputMoleculeIDs = []
		self._outputMoleculeCoeffs = []

		self.reactionStoich = reactionStoich.copy()

		# Keep track of non-standard reactions
		self._specialFluxIDsSet = set()
		self._kineticTargetFluxes = set()
		self._oneSidedReactions = set()

		# Keep track of homeostatic targets, empty if not used
		self._homeostaticTargetMolecules = set()

		# Call indivdual initialization methods
		self._initReactionNetwork(self.reactionStoich)
		self._initExternalExchange(externalExchangedMolecules)

		if objectiveType is None or objectiveType == "standard":
			self._initObjectiveEquivalents(objective)
			self._initObjectiveStandard(objective)

		elif objectiveType == "flexible":
			self._initObjectiveEquivalents(objective)
			self._initObjectiveFlexible(objective, objectiveParameters)

		elif objectiveType == "homeostatic":
			self._initObjectiveEquivalents(objective)
			self._initObjectiveHomeostatic(objective)

			if internalExchangedMolecules is not None:
				raise FBAError(
					"Internal exchange molecules are automatically defined when using self.objectiveType = \"homeostatic\""
					)
			internalExchangedMolecules = sorted(objective.keys())

		elif self.objectiveType == "range_homeostatic":
			self._initObjectiveEquivalents(objective)
			self._initObjectiveRangeHomeostatic(objective, objectiveParameters)

			if internalExchangedMolecules is not None:
				raise FBAError(
					"Internal exchange molecules are automatically defined when using self.objectiveType = \"range_homeostatic\""
					)
			internalExchangedMolecules = sorted(objective.keys())

		elif self.objectiveType == "kinetic_only":
			if "reactionRateTargets" in objectiveParameters:
				rateObjective = objectiveParameters["reactionRateTargets"]
			else:
				raise FBAError("When using homeostatic_kinetics_mixed objective, a reactionRateTargets dict of reactionName:target rate must be provided in objectiveParameters.")

			self._initObjectiveKinetic(rateObjective, objectiveParameters)

		elif self.objectiveType == "homeostatic_kinetics_mixed":
			# Set up homeostatic objective
			self._initObjectiveEquivalents(objective)
			self._initObjectiveRangeHomeostatic(objective, objectiveParameters)

			if internalExchangedMolecules is not None:
				raise FBAError(
					"Internal exchange molecules are automatically defined when using self.objectiveType = \"homeostatic_kinetics_mixed\""
					)
			internalExchangedMolecules = sorted(objective.keys())

			# Set up kinetic objective
			if "reactionRateTargets" in objectiveParameters:
				rateObjective = objectiveParameters["reactionRateTargets"]
			else:
				raise FBAError("When using homeostatic_kinetics_mixed objective, a reactionRateTargets dict of reactionName:target rate must be provided in objectiveParameters.")

			self._initObjectiveKinetic(rateObjective, objectiveParameters)

		else:
			raise FBAError("Unrecognized self.objectiveType: {}".format(self.objectiveType))

		self._initInternalExchange(internalExchangedMolecules)

		self._initExchangeMass(externalExchangedMolecules, moleculeMasses, secretionPenaltyCoeff)

		self._initMaintenance(maintenanceCostGAM, maintenanceReaction)

		# Set up values that will change between runs

		self.externalMoleculeLevelsIs(0)
		self.internalMoleculeLevelsIs(0)

		self._buildEqConst()

	def _initReactionNetwork(self, reactionStoich):
		""" Create the reaction network, initializing molecules and biochemical
		reactions. """

		reactionIDs = []

		for reactionID in sorted(reactionStoich):
			stoichiometry = reactionStoich[reactionID]
			for moleculeID, stoichCoeff in stoichiometry.viewitems():
				self._solver.flowMaterialCoeffIs(
					reactionID,
					moleculeID,
					stoichCoeff
					)

			reactionIDs.append(reactionID)

		self._reactionIDs = tuple(reactionIDs)
		self._reactionIDsSet = set(reactionIDs)


	def _initExternalExchange(self, externalExchangedMolecules):
		"""Create external (media) exchange reactions."""

		externalMoleculeIDs = []
		externalExchangeIDs = []

		for moleculeID in externalExchangedMolecules:
			exchangeID = self._generatedID_externalExchange.format(moleculeID)

			# NOTE: The convention, if I am not mistaken, is to define
			# exchanges as pointing out of the system, even though it is common
			# to think of exchanges as inputs.  Regardless this choice should
			# have no impact outside of this class.

			self._solver.flowMaterialCoeffIs(
				exchangeID,
				moleculeID,
				-1
				)

			externalMoleculeIDs.append(moleculeID)
			externalExchangeIDs.append(exchangeID)
			self._specialFluxIDsSet.add(exchangeID)

		self._externalMoleculeIDs = tuple(externalMoleculeIDs)
		self._externalExchangeIDs = tuple(externalExchangeIDs)


	def _initObjectiveEquivalents(self,
								objective,
								pseudoFluxFormat=None,
								objectiveEquivFormat=_generatedID_moleculeEquivalents):
		"""Create pseudo-reactions that convert molecules into their fractional
		objective equivalents.  The objectiveType determines how these
		fractions are used."""

		# Use default format strings if none provided
		if pseudoFluxFormat is None:
			pseudoFluxFormat=self._generatedID_moleculesToEquivalents
		if objectiveEquivFormat is None:
			objectiveEquivFormat=self._generatedID_moleculeEquivalents

		for moleculeID in sorted(objective):
			coeff = objective[moleculeID]
			if coeff == 0:
				raise FBAError("Invalid objective coefficient - must be non-zero")

			pseudoFluxID = pseudoFluxFormat.format(moleculeID)

			objectiveEquivID = objectiveEquivFormat.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				pseudoFluxID,
				moleculeID,
				-coeff
				)

			self._solver.flowMaterialCoeffIs(
				pseudoFluxID,
				objectiveEquivID,
				+1
				)

			# Objective molecules are output molecules
			if moleculeID in self._outputMoleculeIDs:
				i = self._outputMoleculeIDs.index(moleculeID)
			else:
				self._outputMoleculeIDs.append(moleculeID)
				self._outputMoleculeCoeffs.append(dict())
				i = len(self._outputMoleculeIDs) - 1

			self._outputMoleculeCoeffs[i][pseudoFluxID] = -coeff


	def _initObjectiveStandard(self, objective):
		"""Create the pseudo-reaction for the standard biomass objective.  In
		the standard objective, all molecules must be created/destroyed in
		prescribed ratios."""

		for moleculeID in objective.viewkeys():
			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				self._standardObjectiveReactionName,
				objectiveEquivID,
				-1
				)

		self._solver.flowObjectiveCoeffIs(
			self._standardObjectiveReactionName,
			+1
			)


	def _initObjectiveFlexible(self, objective, objectiveParameters):
		"""Create the abstractions needed for the flexFBA objective.  In brief,
		flexFBA permits partial biomass objective satisfaction for individual
		molecules if network disruptions inhibit molecule production."""

		# Load parameters
		leadingMoleculeID = objectiveParameters["leading molecule ID"]

		if not objective.has_key(leadingMoleculeID):
			raise FBAError("flexFBA leading molecule must be in the objective")

		fractionalDifferenceWeight = objectiveParameters["gamma"]

		if fractionalDifferenceWeight < 0:
			raise FBAError("flexFBA gamma paramter must be nonnegative")

		biomassSatisfactionWeight = objectiveParameters["beta"]

		if biomassSatisfactionWeight < 0:
			raise FBAError("flexFBA beta paramter must be nonnegative")

		if any(coeff < 0 for coeff in objective.viewvalues()):
			warnings.warn("flexFBA is not designed to use negative biomass coefficients")

		# Add biomass to objective
		self._solver.flowObjectiveCoeffIs(
			self._standardObjectiveReactionName,
			biomassSatisfactionWeight
			)

		# Create fraction and biomass outputs
		for moleculeID in objective.viewkeys():
			fractionID = self._generatedID_moleculeEquivalents.format(moleculeID)

			# Biomass out
			self._solver.flowMaterialCoeffIs(
				self._standardObjectiveReactionName,
				fractionID,
				-1
				)

			# Fraction out
			fractionOutID = self._generatedID_fractionsOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				fractionOutID,
				fractionID,
				-1
				)

			if moleculeID == leadingMoleculeID:
				# Add leading molecule to objective
				self._solver.flowObjectiveCoeffIs(
					fractionOutID,
					+1
					)

		# Create fraction differences (leading - other), used in objective and constraints
		leadingMoleculeToFractionID = self._generatedID_moleculesToEquivalents.format(leadingMoleculeID)

		for moleculeID in objective.viewkeys():
			if moleculeID == leadingMoleculeID:
				continue

			fractionDifferenceLeadingID = self._generatedID_fractionalDifferenceLeading.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				leadingMoleculeToFractionID,
				fractionDifferenceLeadingID,
				+1
				)

			moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				moleculeToFractionID,
				fractionDifferenceLeadingID,
				-1
				)

			fractionDifferenceLeadingOutID = self._generatedID_fractionalDifferenceLeadingOut.format(moleculeID)

			self._solver(
				fractionDifferenceLeadingOutID,
				fractionDifferenceLeadingID,
				-1
				)

			self._solver.flowObjectiveCoeffIs(
				fractionDifferenceLeadingOutID,
				-fractionalDifferenceWeight
				)

		# Create biomass differences (fraction - biomass), used in constraints

		for moleculeID in objective.viewkeys():
			fractionDifferenceBiomassID = self._generatedID_fractionalDifferenceBiomass.format(moleculeID)

			moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				moleculeToFractionID,
				fractionDifferenceBiomassID,
				+1
				)

			self._solver.flowMaterialCoeffIs(
				fractionDifferenceBiomassID,
				self._standardObjectiveReactionName,
				-1
				)

			fractionDifferenceBiomassOutID = self._generatedID_fractionalDifferenceBiomassOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				fractionDifferenceBiomassOutID,
				fractionDifferenceBiomassID,
				-1
				)

	def _initObjectiveHomeostatic(self, objective):
		"""Create the abstractions needed for homeostatic FBA.  The objective is
		to minimize the distance between the current metabolite level and some
		target level, as defined in the objective."""

		if any(coeff < 0 for coeff in objective.viewvalues()):
			raise FBAError("Homeostatic FBA is not designed to use negative biomass coefficients")

		self._solver.maximizeObjective(False)
		self._forceInternalExchange = True

		# By forcing a column to be at unity, we can keep the definition of
		# the problem as b=Av where b=0.

		self._solver.flowLowerBoundIs(
			self._forcedUnityColName,
			+1
			)

		self._solver.flowUpperBoundIs(
			self._forcedUnityColName,
			+1
			)

		# Minimizing an absolute value requires splitting the term into two,
		# one for the positive values and one for the negative.

		for moleculeID in sorted(objective):
			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

			# Add the forced -1 term so that we can define x_i = f_i - 1

			self._solver.flowMaterialCoeffIs(
				self._forcedUnityColName,
				objectiveEquivID,
				-1
				)

			# Add the term for when the flux out is below the expected value

			belowUnityID = self._generatedID_fractionBelowUnityOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				belowUnityID,
				objectiveEquivID,
				+1
				)

			self._solver.flowObjectiveCoeffIs(
				belowUnityID,
				+1
				)

			# Add the term for when the flux out is above the expected value
			aboveUnityID = self._generatedID_fractionAboveUnityOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				aboveUnityID,
				objectiveEquivID,
				-1
				)

			self._solver.flowObjectiveCoeffIs(
				aboveUnityID,
				+1
				)

	def _initObjectiveRangeHomeostatic(self, objective, objectiveParameters):
		""" Homeostatic FBA with a range of acceptable values. The objective is
		to minimize the distance between the current metabolite level and a range
		of target concentrations. Within this target range, there is a small preference
		for the higher concentraion. The low and high ends of the target range are
		defined in the objective."""

		# Load parameters - default to regular homeostatic fba if none given
		homeostaticRangeObjFractionHigher = objectiveParameters["homeostaticRangeObjFractionHigher"] if "homeostaticRangeObjFractionHigher" in objectiveParameters else 0
		inRangeObjWeight = objectiveParameters["inRangeObjWeight"] if "inRangeObjWeight" in objectiveParameters else 0
		kineticObjectiveWeight = objectiveParameters["kineticObjectiveWeight"] if "kineticObjectiveWeight" in objectiveParameters else 0

		# Track which molecules have homeostatic tagets
		self._homeostaticTargetMolecules.update(set(objective.keys()))

		if kineticObjectiveWeight > 1 or kineticObjectiveWeight < 0:
			raise FBAError("kineticObjectiveWeight must be between 0 and 1 inclusive. It represents the percentage of preference going to kinetics.")
		else:
			self._homeostaticObjectiveWeight = (1 - kineticObjectiveWeight)

		if inRangeObjWeight > 1 or inRangeObjWeight < 0:
			raise FBAError("inRangeObjWeight must be between 0 and 1 inclusive. It represents the weighting relative to the out-of-range relaxation fluxes, it must always be less than 1 and positive.")

		self._solver.maximizeObjective(False)
		self._forceInternalExchange = True

		# By forcing a column to be at unity, we can keep the definition of
		# the problem as b=Av where b=0.
		self._solver.flowLowerBoundIs(
			self._forcedUnityColName,
			+1
			)

		self._solver.flowUpperBoundIs(
			self._forcedUnityColName,
			+1
			)

		for moleculeID in sorted(objective):
			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

			# Add the forced -1 term so that we can define x_i = f_i - 1
			self._solver.flowMaterialCoeffIs(
				self._forcedUnityColName,
				objectiveEquivID,
				-1
				)

			# Add the term for when the flux out is below the expected range
			belowUnityID = self._generatedID_fractionBelowUnityOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				belowUnityID,
				objectiveEquivID,
				+1
				)

			self._solver.flowObjectiveCoeffIs(
				belowUnityID,
				+(self._homeostaticObjectiveWeight)
				)

			# Add the term for when the flux out is within the expected range
			inRangeID = self._generatedID_fractionInRangeOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				inRangeID,
				objectiveEquivID,
				-homeostaticRangeObjFractionHigher if homeostaticRangeObjFractionHigher > 0 else homeostaticRangeObjFractionHigher
				)

			# Set the weight of running this relaxation
			self._solver.flowObjectiveCoeffIs(
				inRangeID,
				+inRangeObjWeight*(self._homeostaticObjectiveWeight)
				)

			# This relaxation can only go to the end of the target range (less and the out range relaxation must be used)
			self._solver.flowUpperBoundIs(
				inRangeID,
				+abs(homeostaticRangeObjFractionHigher)
				)


			# Add the term for when the flux out is above the target value and out of the expected range
			aboveUnityID = self._generatedID_fractionAboveUnityOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				aboveUnityID,
				objectiveEquivID,
				-1
				)

			self._solver.flowObjectiveCoeffIs(
				aboveUnityID,
				+(self._homeostaticObjectiveWeight)
				)

	def _initObjectiveKinetic(self, objective, objectiveParameters=None):
		""" Given a dict of reaction_name:rate (objective), attempts to
			minimize the L1 normalized distance between fluxes and those rates.
		"""

		self.kineticObjectiveWeight = objectiveParameters["kineticObjectiveWeight"] if "kineticObjectiveWeight" in objectiveParameters else 0

		# Unless given, assume no reactions are one-sided targets (ie kcat only targets)
		self._oneSidedReactions = set(objectiveParameters["oneSidedReactionTargets"]) if "oneSidedReactionTargets" in objectiveParameters else set()

		# Track the kinetic target levels
		self._currentKineticTargets = objective

		# This is a minimization objective problem
		self._solver.maximizeObjective(False)

		# Forced a column to always be one
		self._solver.flowLowerBoundIs(
			self._forcedUnityColName,
			+1
			)

		self._solver.flowUpperBoundIs(
			self._forcedUnityColName,
			+1
			)

		for reactionID, expectedFlux in objective.iteritems():
			if expectedFlux < 0:
				raise FBAError("Target flux for reaction {} is negative. Kinetic targets must be postive - set the value for the (reverse) reaction if a negative flux is desired.".format(reactionID))

			if reactionID not in self.reactionStoich:
				raise FBAError("{} is not in the reaction network. Target fluxes must be in the reaction network".format(reactionID))

			self._kineticTargetFluxes.add(reactionID)

			reactionFluxEquivalent = self._generatedID_reactionFluxEquivalents.format(reactionID)
			# Add a term to the reaction to create a kinetic objective equivalent each time it's run
			self._solver.flowMaterialCoeffIs(
				reactionID,
				reactionFluxEquivalent,
				1.
				)

			# Conversion to scale reactions to their target (this is what is changed when changing targets)
			conversionFlux = self._generatedID_conversionFlux.format(reactionID)
			kineticObjEquivalent = self._generatedID_kineticReactionEquivalents.format(reactionID)
			self._solver.flowMaterialCoeffIs(
				conversionFlux,
				reactionFluxEquivalent,
				-expectedFlux
				)
			self._solver.flowMaterialCoeffIs(
				conversionFlux,
				kineticObjEquivalent,
				1
				)

			# Force consumption of one kinetic objective equivalent
			self._solver.flowMaterialCoeffIs(
				self._forcedUnityColName,
				kineticObjEquivalent,
				-1
				)

			## Create relaxation fluxes to allow deviation from this forced consumption
			# Above
			# Add a pseudoreaction to allow the flux to be above its target
			overTargetFlux = self._generatedID_amountOver.format(reactionID)
			self._solver.flowMaterialCoeffIs(
				overTargetFlux,
				kineticObjEquivalent,
				-1
				)
			# Objective is to minimize running this relaxation reaction
			self._solver.flowObjectiveCoeffIs(
				overTargetFlux,
				(self.kineticObjectiveWeight)
			)

			self._specialFluxIDsSet.add(overTargetFlux)

			# Below
			# Add a pseudoreaction to allow the flux to be below its target
			underTargetFlux = self._generatedID_amountUnder.format(reactionID)
			self._solver.flowMaterialCoeffIs(
				underTargetFlux,
				kineticObjEquivalent,
				1
				)
			# Objective is to minimize running this relaxation reaction, unless this is a one-sided kinetic target, in which case it's a free relaxation.
			if reactionID not in self._oneSidedReactions:
				self._solver.flowObjectiveCoeffIs(
					underTargetFlux,
					(self.kineticObjectiveWeight)
					)

			self._specialFluxIDsSet.add(underTargetFlux)


	def _initInternalExchange(self, internalExchangedMolecules):
		"""Create internal (byproduct) exchange reactions."""

		internalMoleculeIDs = []

		if internalExchangedMolecules is not None:
			for moleculeID in internalExchangedMolecules:
				exchangeID = self._generatedID_internalExchange.format(moleculeID)

				self._solver.flowMaterialCoeffIs(
					exchangeID,
					moleculeID,
					-1
					)

				internalMoleculeIDs.append(moleculeID)
				self._specialFluxIDsSet.add(exchangeID)

				# TODO: functionalize
				try:
					i = self._outputMoleculeIDs.index(moleculeID)

				except ValueError:
					self._outputMoleculeIDs.append(moleculeID)
					self._outputMoleculeCoeffs.append(dict())
					i = len(self._outputMoleculeIDs) - 1

				self._outputMoleculeCoeffs[i][exchangeID] = -1

		self._internalMoleculeIDs = tuple(internalMoleculeIDs)

	def _initExchangeMass(self, externalExchangedMolecules, moleculeMasses, secretionPenaltyCoeff):
		"""Create mass accumulation abstractions.
		Tracking the mass entering the system through metabolism is crucial for
		insuring closure. It can also be used to constrain the maximal rate of
		growth."""

		if moleculeMasses is not None:
			self._solver.flowMaterialCoeffIs(
				self._massExchangeOutName,
				self._massExchangeID,
				-1
				)

			for moleculeID in externalExchangedMolecules:
				exchangeFluxID = self._generatedID_externalExchange.format(moleculeID)

				try:
					moleculeMass = moleculeMasses[moleculeID]

				except KeyError:
					raise FBAError("You must provide masses for all molecules in externalExchangedMolecules")

				self._solver.flowMaterialCoeffIs(
					exchangeFluxID,
					self._massExchangeID,
					-moleculeMass # NOTE: negative because exchange fluxes point out
					)

				if secretionPenaltyCoeff is not None:
					# Limit secretion/export
					absID = self._generatedID_externalExchangeAbs.format(moleculeID)
					posExchangeID = self._generatedID_externalExchangePos.format(moleculeID)
					negExchangeID = self._generatedID_externalExchangeNeg.format(moleculeID)

					self._solver.flowMaterialCoeffIs(
						exchangeFluxID,
						absID,
						moleculeMass
						)

					self._solver.flowMaterialCoeffIs(
						posExchangeID,
						absID,
						-1
						)

					self._solver.flowMaterialCoeffIs(
						negExchangeID,
						absID,
						+1
						)

					self._solver.flowObjectiveCoeffIs(
						posExchangeID,
						secretionPenaltyCoeff
					)


	def _initMaintenance(self, maintenanceCostGAM, maintenanceReaction):
		"""Create growth-associated maintenance abstractions.
		Two maintenance costs are typically associated with FBA; growth-
		associated maintenance is the energetic cost of increasing cell mass by
		a certain amount.  (Contrast non-growth-associated maintenance, which
		is a fixed energetic cost regardless of mass accumulation.)
		"""

		if (maintenanceCostGAM is None) and (maintenanceReaction is None):
			return

		if (maintenanceCostGAM is None) ^ (maintenanceReaction is None):
			raise FBAError("Must pass all or none of maintenanceCostGAM, maintenanceReaction")


		# TODO: check that the mass flux stuff exists

		# computed mass output produces "GAM reactions"...

		self._solver.flowMaterialCoeffIs(
			self._massExchangeOutName,
			self._pseudometaboliteGAM,
			maintenanceCostGAM
			)

		# ... which are consumed in a seperate flux

		self._solver.flowMaterialCoeffIs(
			self._reactionID_GAM,
			self._pseudometaboliteGAM,
			-1
			)

		for moleculeID, stoichCoeff in maintenanceReaction.viewitems():
			self._solver.flowMaterialCoeffIs(
				self._reactionID_GAM,
				moleculeID,
				stoichCoeff
				)

			self._solver.flowMaterialCoeffIs(
				self._reactionID_NGAM,
				moleculeID,
				stoichCoeff
				)

			self._solver.flowMaterialCoeffIs(
				self._reactionID_polypeptideElongationEnergy,
				moleculeID,
				stoichCoeff
				)

		self._specialFluxIDsSet.add(self._reactionID_GAM)
		self._specialFluxIDsSet.add(self._reactionID_NGAM)
		self._specialFluxIDsSet.add(self._reactionID_polypeptideElongationEnergy)


	def _buildEqConst(self):
		try:
			self._solver.buildEqConst()
		except AttributeError:
			return


	# Constraint setup

	# NOTE: I've used the nonspecific term "levels" since these could be
	# mole-concentration, number-concentration, or counts, depending on the
	# formulation of the problem.  All that matters is that initialization
	# parameters have consistent units.

	def externalMoleculeIDs(self):
		return self._externalMoleculeIDs


	def externalMoleculeLevelsIs(self, levels):
		levels_array = np.empty(len(self._externalMoleculeIDs))
		levels_array[:] = levels

		for moleculeID, level in izip(self._externalMoleculeIDs, levels_array):
			flowID = self._generatedID_externalExchange.format(moleculeID)

			if level < 0:
				print "Setting a negative external molecule level - be sure this is intended behavior."

				self._solver.flowUpperBoundIs(
					flowID,
					-level
					)
			else:
				self._solver.flowLowerBoundIs(
					flowID,
					-level
					)


	def internalMoleculeIDs(self):
		return self._internalMoleculeIDs


	def internalMoleculeLevelsIs(self, levels):
		levels_array = np.empty(len(self._internalMoleculeIDs))
		levels_array[:] = levels

		if (levels_array < 0).any():
			raise InvalidBoundaryError("Negative molecule levels not allowed")

		for moleculeID, level in izip(self._internalMoleculeIDs, levels_array):
			flowID = self._generatedID_internalExchange.format(moleculeID)

			self._solver.flowLowerBoundIs(
				flowID,
				-level
				)

			if self._forceInternalExchange:
				self._solver.flowUpperBoundIs(
					flowID,
					-level
					)


	def reactionIDs(self):
		return np.array(self._reactionIDs)


	def maxReactionFluxIs(self, reactionID, maxFlux, raiseForReversible = True):
		if maxFlux < 0:
			raise InvalidBoundaryError("Maximum reaction flux must be at least 0")

		if reactionID not in self._reactionIDsSet and reactionID not in self._specialFluxIDsSet:
			raise InvalidBoundaryError("Unable to set max reaction flux: reaction '%s' not recognized." % (reactionID))

		# if maxFlux < self._lowerBound[colIndex]:
		# 	raise InvalidBoundaryError("Maximum reaction flux must be greater than or equal to the minimum flux")

		reverseReactionID = self._generatedID_reverseReaction.format(reactionID)

		if raiseForReversible and reverseReactionID in self._reactionIDs:
			raise FBAError((
				"Setting the maximum reaction flux is ambiguous since " +
				"reaction {} has both a forward [{}] and reverse [{}] " +
				"component.  Call this method with argument " +
				"raiseForReversible = False if this is intended behavior."
				).format(reactionID, reactionID, reverseReactionID))

		self._solver.flowUpperBoundIs(
			reactionID,
			maxFlux
			)


	def minReactionFluxIs(self, reactionID, minFlux, raiseForReversible = True):
		if minFlux < 0:
			raise InvalidBoundaryError("Minimum reaction flux must be at least 0")

		if reactionID not in self._reactionIDsSet and reactionID not in self._specialFluxIDsSet:
			raise InvalidBoundaryError("Unable to set min reaction flux: reaction '%s' not recognized." % (reactionID))

		# if minFlux > self._upperBound[colIndex]:
		# 	raise InvalidBoundaryError("Minimum reaction flux must be less than or equal to the maximum flux")

		reverseReactionID = self._generatedID_reverseReaction.format(reactionID)

		if raiseForReversible and reverseReactionID in self._reactionIDs:
			raise FBAError((
				"Setting the minimum reaction flux is ambiguous since " +
				"reaction {} has both a forward [{}] and reverse [{}] " +
				"component.  Call this method with argument " +
				"raiseForReversible = False if this is intended behavior."
				).format(reactionID, reactionID, reverseReactionID))

		self._solver.flowLowerBoundIs(
			reactionID,
			minFlux
			)

	def setMaxReactionFluxes(self, reactionIDs, reactionRates, raiseForReversible=True):
		if len(reactionIDs) != len(reactionRates):
			raise Exception("There must be equal numbers of reactionIDs and rates to set limits.")

		for idx, reactionID in enumerate(reactionIDs):
			self.maxReactionFluxIs(reactionID, reactionRates[idx], raiseForReversible)

	def setMinReactionFluxes(self, reactionIDs, reactionRates, raiseForReversible=True):
		if len(reactionIDs) != len(reactionRates):
			raise Exception("There must be equal numbers of reactionIDs and rates to set limits.")

		for idx, reactionID in enumerate(reactionIDs):
			self.minReactionFluxIs(reactionID, reactionRates[idx], raiseForReversible)

	def setpointIs(self, moleculeID, coeff):
		if moleculeID not in self._outputMoleculeIDs:
			raise FBAError(
				"setpointIs() only allows for modification of setpoint values, " +
				"not adding new ones. %s is an unrecognized molecule" % moleculeID
				)

		pseudoFluxID = self._generatedID_moleculesToEquivalents.format(moleculeID)

		objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

		self._solver.flowMaterialCoeffIs(
			pseudoFluxID,
			moleculeID,
			-coeff
			)

		i = self._outputMoleculeIDs.index(moleculeID)
		self._outputMoleculeCoeffs[i][pseudoFluxID] = -coeff

	def maxMassAccumulatedIs(self, maxAccumulation):
		self._solver.flowUpperBoundIs(
			self._massExchangeOutName,
			maxAccumulation
			)

	# Output

	def outputMoleculeIDs(self):
		return tuple(self._outputMoleculeIDs)


	def outputMoleculeLevelsChange(self):
		# This is essentially a dot product, need to profile to make sure this
		# isn't horribly slow

		change = np.zeros(len(self._outputMoleculeIDs))

		for i, outputMoleculeID in enumerate(self._outputMoleculeIDs):
			for reactionID, coeff in self._outputMoleculeCoeffs[i].viewitems():
				change[i] += self._solver.flowRates(reactionID) * coeff

		return -change

	def externalExchangeFluxes(self):
		return self._solver.flowRates(self._externalExchangeIDs)

	def externalExchangeFlux(self, moleculeID):
		fluxID = self._generatedID_externalExchange.format(moleculeID)
		if fluxID not in self._externalExchangeIDs:
			raise FBAError("{} is not a known externally exchanged molecule.".format(moleculeID))
		return -self._solver.flowRates(fluxID)

	# def internalExchangeFlux(self, moleculeID):
	# 	if moleculeID not in self._fluxIndex:
	# 		raise FBAError("{} is not a known internally exchanged molecule.".format(moleculeID))
	# 	return -self._solutionFluxes[
	# 		self._fluxIndex(self._generatedID_internalExchange.format(moleculeID))
	# 		]

	def reactionFlux(self, reactionID):
		return self._solver.flowRates(reactionID)

	def reactionFluxes(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self._reactionIDs
		return self._solver.flowRates(reactionIDs)

	def rowDualValues(self, moleculeIDs):
		return self._solver.rowDualValues(moleculeIDs)

	def columnDualValues(self, moleculeIDs):
		return self._solver.columnDualValues(moleculeIDs)

	def biomassReactionFlux(self):
		if self.objectiveType not in ("standard", "flexible", "moma"):
			raise FBAError("There is no biomass reaction for this objective type ({})".format(self.objectiveType))
		return self._solver.flowRates(self._standardObjectiveReactionName)[0]

	def homeostaticObjectiveValues(self, moleculeIDs=None):
		if moleculeIDs is None:
			moleculeIDs = self.homeostaticTargetMolecules()
		values = np.zeros(len(moleculeIDs))
		for idx, moleculeID in enumerate(moleculeIDs):
			if moleculeID not in self._homeostaticTargetMolecules:
				raise FBAError("No homeostatic target set for molecule {}.".format(moleculeID))
			belowUnityID = self._generatedID_fractionBelowUnityOut.format(moleculeID)
			aboveUnityID = self._generatedID_fractionAboveUnityOut.format(moleculeID)
			relaxUp = self.reactionFlux(belowUnityID)
			relaxDown = self.reactionFlux(aboveUnityID)

			assert relaxUp <= NUMERICAL_ZERO or relaxDown <= NUMERICAL_ZERO

			values[idx] = relaxUp + relaxDown
		return values

	def homeostaticObjectiveWeight(self):
		return self._homeostaticObjectiveWeight

	def homeostaticTargetMolecules(self):
		return sorted(self._homeostaticTargetMolecules)

	def objectiveValue(self):
		return self._solver.objectiveValue()

	def kineticTargetFluxes(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self.kineticTargetFluxNames()
		values = np.zeros(len(reactionIDs))
		for idx, reactionID in enumerate(reactionIDs):
			if reactionID not in self._kineticTargetFluxes:
				raise FBAError("{} is not a kinetic target flux.".format(reactionID))
			values[idx] = self.reactionFlux(reactionID)
		return values

	def kineticTargetFluxTargets(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self.kineticTargetFluxNames()
		values = np.zeros(len(reactionIDs))
		for idx, reactionID in enumerate(reactionIDs):
			if reactionID not in self._currentKineticTargets:
				raise FBAError("No kinetic target set for reaction {}.".format(reactionID))
			values[idx] = self._currentKineticTargets[reactionID]
		return values

	def kineticTargetFluxErrors(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self.kineticTargetFluxNames()
		errors = self.kineticTargetFluxes(reactionIDs) - self.kineticTargetFluxTargets(reactionIDs)
		# Adjust for any one-sided reactions
		if len(self._oneSidedReactions) > 0:
			oneSidedNegativeErrors = np.where([True if reactionID in self._oneSidedReactions and errors[idx] < 0 else False for idx, reactionID in enumerate(reactionIDs)])
			errors[oneSidedNegativeErrors] = 0
		return errors

	def kineticTargetFluxRelativeDifferences(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self.kineticTargetFluxNames()
		return self.kineticTargetFluxErrors(reactionIDs) / self.kineticTargetFluxTargets(reactionIDs)

	def kineticTargetFluxNames(self):
		return sorted(self._kineticTargetFluxes)

	def kineticOneSidedTargetFluxNames(self):
		return sorted(self._oneSidedReactions)

	def kineticObjectiveValues(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self.kineticTargetFluxNames()
		fluxes = self.kineticTargetFluxes(reactionIDs)
		targets = self.kineticTargetFluxTargets(reactionIDs)
		return np.abs(np.ones_like(fluxes) - fluxes/targets)

	def setKineticTarget(self, reactionIDs, reactionTargets, raiseForReversible=True):
		# If a single value is passed in, make a list of length 1 from it
		if isinstance(reactionIDs, str) or isinstance(reactionIDs, unicode):
			reactionIDs = [reactionIDs]
		if not (isinstance(reactionTargets, list) or isinstance(reactionTargets, np.ndarray)):
			reactionTargets = [reactionTargets]

		if len(reactionIDs) != len(reactionTargets):
			raise Exception("There must be equal numbers of reactionIDs and reactionTargets when changing the kinetic target.")

		if (np.array(reactionTargets) < 0).any():
			raise FBAError("Rate targets cannot be negative. {} were provided with targets of {}".format(np.array(reactionIDs)[np.array(reactionTargets) < 0], np.array(reactionTargets)[np.array(reactionTargets) < 0]))

		# Change the objective normalization
		for reactionID, reactionTarget in izip(reactionIDs,reactionTargets):
			if reactionID not in self._kineticTargetFluxes:
				raise FBAError("Kinetic targets can only be set for reactions initialized to be kinetic targets. {} is not set up for it.".format(reactionID))

			conversionFlux = self._generatedID_conversionFlux.format(reactionID)
			reactionFluxEquivalent = self._generatedID_reactionFluxEquivalents.format(reactionID)
			if reactionTarget == 0:
				# can't have coeff = 0, target is disabled so -1 is arbitrary value that won't matter
				self._solver.flowMaterialCoeffIs(
					conversionFlux,
					reactionFluxEquivalent,
					-1
					)
				self.disableKineticTargets(reactionID)
			else:
				if self._currentKineticTargets[reactionID] == 0:
					self.enableKineticTargets(reactionID)
				self._solver.flowMaterialCoeffIs(
					conversionFlux,
					reactionFluxEquivalent,
					-reactionTarget
					)

			# Record the change
			self._currentKineticTargets[reactionID] = reactionTarget

	def enableKineticTargets(self, reactionIDs=None):
		# If a single value is passed in, make a list of length 1 from it
		if isinstance(reactionIDs, str) or isinstance(reactionIDs, unicode):
			reactionIDs = [reactionIDs]

		# If no reactions specified, enable all kinetic reactions
		if reactionIDs == None:
			print "enabled kinetic rates"
			reactionIDs = self.kineticTargetFluxNames()

		for reactionID in reactionIDs:
			# Add objective weighting to these reaction's relaxation fluxes
			# Above
			overTargetFlux = self._generatedID_amountOver.format(reactionID)
			# Objective is to minimize running this relaxation reaction
			self._solver.flowObjectiveCoeffIs(
				overTargetFlux,
				(self.kineticObjectiveWeight)
			)
			# Below
			underTargetFlux = self._generatedID_amountUnder.format(reactionID)
			if reactionID not in self._oneSidedReactions:
				self._solver.flowObjectiveCoeffIs(
					underTargetFlux,
					(self.kineticObjectiveWeight)
				)

	def disableKineticTargets(self, reactionIDs=None):
		# If a single value is passed in, make a list of length 1 from it
		if isinstance(reactionIDs, str) or isinstance(reactionIDs, unicode):
			reactionIDs = [reactionIDs]

		# If no reactions specified, disable all kinetic reactions
		if reactionIDs == None:
			print "disabled kinetic rates"
			reactionIDs = self.kineticTargetFluxNames()

		for reactionID in reactionIDs:
			# Add objective weighting to these reaction's relaxation fluxes
			# Above
			overTargetFlux = self._generatedID_amountOver.format(reactionID)
			# Objective is to minimize running this relaxation reaction
			self._solver.flowObjectiveCoeffIs(
				overTargetFlux,
				0
			)
			# Below
			underTargetFlux = self._generatedID_amountUnder.format(reactionID)
			self._solver.flowObjectiveCoeffIs(
				underTargetFlux,
				0
			)

			# Reset flux target - leaving low values can cause issues when objective for reaction is disabled
			conversionFlux = self._generatedID_conversionFlux.format(reactionID)
			reactionFluxEquivalent = self._generatedID_reactionFluxEquivalents.format(reactionID)
			self._solver.flowMaterialCoeffIs(
				conversionFlux,
				reactionFluxEquivalent,
				-1
				)

	def getArrayBasedModel(self):
		return {
		"S_matrix": self._solver.getSMatrix(),
		"Reactions": self._solver.getFlowNames(),
		"Metabolites": self._solver.getMaterialNames(),
		"Upper bounds": self._solver.getUpperBounds(),
		"Lower bounds": self._solver.getLowerBounds(),
		"Objective": self._solver.getObjective(),
		}

	def massAccumulated(self):
		return self._solver.flowRates(self._massExchangeOutName)

	def solve(self, iterations):
		if iterations == 0:
			self._solver._solve()
		else:
			try:
				self._solver._solve()
			except Exception as inst:
				print "Warning: {} error while solving FBA - repeating FBA solve".format(inst)
				self.solve(iterations - 1)
