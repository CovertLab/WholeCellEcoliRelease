#!/usr/bin/env python

"""
@author: John Mason
@organization: Covert Lab, Department of Bioengineering, Stanford University
@date: Created 7/14/2014
"""

from __future__ import division

from collections import defaultdict
from itertools import izip
import warnings

import numpy as np

SOLVERS = {}
S_GUROBI = "gurobi"
S_GLPK = "glpk"
_SOLVER_PREFERENCE = (
	S_GUROBI,
	S_GLPK
	)

try:
	from ._netflow.nf_gurobi import NetworkFlowGurobi

except ImportError:
	pass

except Exception as e:
	# If this is a GurobiError, proceed without using gurobi, warning the user.
	if str(type(e)) == "<class 'gurobipy.GurobiError'>":
		print "GurobiError - gurobi will not be used."
	# Otherwise, raise the exception as normal
	else:
		raise e

else:
	SOLVERS[S_GUROBI] = NetworkFlowGurobi

try:
	from ._netflow.nf_glpk import NetworkFlowGLPK

except ImportError:
	pass

else:
	SOLVERS[S_GLPK] = NetworkFlowGLPK

if not SOLVERS:
	raise Exception("No solvers available.")

for solver in _SOLVER_PREFERENCE:
	if solver in SOLVERS:
		DEFAULT_SOLVER = solver
		break

else:
	raise Exception("Could not choose a default solver.")

# Errors

class FBAError(Exception):
	pass


class AlreadyExistsError(FBAError):
	pass


class DoesNotExistError(FBAError):
	pass


class InvalidBoundaryError(FBAError):
	pass


class SolverUnavailableError(FBAError):
	pass

# Classes


class FluxBalanceAnalysis(object):
	""" FluxBalanceAnalysis

	Solver for various FBA implementations.


	Required arguments:

	- reactionStoich, a dict of strings:dicts (reactionID:reaction stoich)
		Each value in the dict is a dict of molecule ID to stoichiometry pairs

	- externalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- objective, a dict of strings:floats (moleculeID:objective value)
		The meaning and usage of the objective will vary depending on the
		formulation of FBA desired.


	Optional arguments (set to None for default behavior):

	- objectiveType, a string
		"standard": standard FBA objective (default)
		"flexible": flexFBA
		"pools": similar to FBA; optimizes towards desired pool concentrations

	- objectiveParameters, a dict
		Keys are specific to the FBA implementation.

	- internalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- reversibleReactions, a list of strings (reactionIDs for reversible reactions)

	- reactionEnzymes, a dict of strings:strings (reactionID:enzymeID)

	- reactionRates, a dict of strings:floats (reactionID:catalytic rate constant * dt)
		Used to set up the pseudo metabolites and boundary constraints needed
		for limiting reactions by enzyme counts.

	- moleculeMasses, a dict of floats (moleculeID:mass)
		Used in computing the net mass into the system.  Only needed and used
		for moleculeIDs in externalExchangedMolecules.


	Caveats:

	There is no strict type checking, despite what the above may imply.

	During initialization, an exception will be raised if a reference is made
	to an unutilized metabolite/enzyme/etc as described by the reaction
	network.

	"""

	# Format strings for autogenerated IDs

	## Reverse reactions
	_generatedID_reverseReaction = "{} (reverse)"

	## Exchange fluxes
	_generatedID_externalExchange = "{} external exchange"
	_generatedID_internalExchange = "{} internal exchange"

	_generatedID_externalExchangePos = "{} external exchange pos"
	_generatedID_externalExchangeNeg = "{} external exchange neg"
	_generatedID_externalExchangeAbs = "{} external exchange abs"

	## Objective
	_generatedID_moleculesToEquivalents = "molecules of {} to fractional objective equivalents"
	_generatedID_moleculeEquivalents = "fractional objective equivalent for {}"

	## Rate-constrained enzymes
	_generatedID_enzymeEquivRateConstrained = "{} equivalent (rate-constrained)"
	_generatedID_enzymeUsageRateConstrained = "{} usage (rate-constrained)"

	## Bool-constrained enzymes
	_generatedID_enzymeEquivBoolConstrained = "{} equivalent (bool-constrained)"
	_generatedID_enzymeUsageBoolConstrained = "{} usage (bool-constrained)"

	## Flex FBA
	_generatedID_fractionalDifferenceLeading = "difference between fractional objective equivalents of leading molecule and {}"
	_generatedID_fractionalDifferenceBiomass = "difference between fractional objective equivalents of {} and biomass objective"

	_generatedID_fractionsOut = "fractional objective equivalents of {} out"
	_generatedID_fractionalDifferenceLeadingOut = "difference between fractional objective equivalents of leading molecule and {} out"
	_generatedID_fractionalDifferenceBiomassOut = "difference between fractional objective equivalents of {} and biomass objective out"

	## Pools FBA
	_generatedID_fractionBelowUnityOut = "fraction {} below unity, out"
	_generatedID_fractionAboveUnityOut = "fraction {} above unity, out"

	_standardObjectiveReactionName = "Standard biomass objective reaction"

	_massExchangeID = "Mass Exchange"
	_massExchangeOutName = "Mass exchange out"

	_forcedUnityColName = "Column forced at unity"

	_pseudometaboliteGAM = "GAM reaction pseudometabolite"
	_reactionID_GAM = "Growth-associated maintenance reaction"
	_reactionID_NGAM = "Non-growth-associated maintenance reaction"
	_reactionID_polypeptideElongationEnergy = "PolypeptideElongation energy reaction"

	## MOMA
	_generatedID_amountOver = "Amount {} flux is over target"
	_generatedID_amountUnder = "Amount {} flux is under target"


	# Default values, for clarity
	_lowerBoundDefault = 0
	_upperBoundDefault = np.inf

	# Initialization

	def __init__(self, reactionStoich, externalExchangedMolecules, objective,
			objectiveType = None, objectiveParameters = None,
			internalExchangedMolecules = None,
			secretionPenaltyCoeff = None, reactionEnzymes = None, reactionRates = None,
			moleculeMasses = None, maintenanceCostGAM = None,
			maintenanceReaction = None,
			solver = DEFAULT_SOLVER):

		if solver not in SOLVERS:
			raise SolverUnavailableError(
				"Unrecognized or unavailable solver: {}".format(solver)
				)

		self.objectiveType = objectiveType

		if objectiveType is None:
			self.objectiveType = "standard"

		self._solver = SOLVERS[solver]()

		self._forceInternalExchange = False

		# Output calculations
		self._outputMoleculeIDs = []
		self._outputMoleculeCoeffs = []

		self.reactionStoich = reactionStoich.copy()

		# Keep track of non-standard reactions
		self._specialFluxIDsSet = set()

		# Call indivdual initialization methods
		self._initReactionNetwork(self.reactionStoich)
		self._initExternalExchange(externalExchangedMolecules)

		if self.objectiveType == "standard":
			self._initObjectiveStandard(objective)

		elif self.objectiveType == "flexible":
			self._initObjectiveFlexible(objective, objectiveParameters)

		elif self.objectiveType == "pools":
			self._initObjectivePools(objective)

			if internalExchangedMolecules is not None:
				raise FBAError(
					"Internal exchange molecules are automatically defined when using self.objectiveType = \"pools\""
					)
			internalExchangedMolecules = sorted(objective.keys())

		elif self.objectiveType == "moma":
			self._initObjectiveMOMA(objective, objectiveParameters)

		else:
			raise FBAError("Unrecognized self.objectiveType: {}".format(self.objectiveType))

		self._initInternalExchange(internalExchangedMolecules)

		self._initEnzymeConstraints(reactionEnzymes, reactionRates)

		self._initExchangeMass(externalExchangedMolecules, moleculeMasses, secretionPenaltyCoeff)

		self._initMaintenance(maintenanceCostGAM, maintenanceReaction)

		# Set up values that will change between runs

		self.externalMoleculeLevelsIs(0)
		self.internalMoleculeLevelsIs(0)
		self.enzymeLevelsIs(0)

		self._buildEqConst()

	def _initReactionNetwork(self, reactionStoich):
		""" Create the reaction network, initializing molecules and biochemical
		reactions. """

		reactionIDs = []

		for reactionID in sorted(reactionStoich):
			stoichiometry = reactionStoich[reactionID]
			for moleculeID, stoichCoeff in stoichiometry.viewitems():
				self._solver.flowMaterialCoeffIs(
					reactionID,
					moleculeID,
					stoichCoeff
					)

			reactionIDs.append(reactionID)

		self._reactionIDs = tuple(reactionIDs)
		self._reactionIDsSet = set(reactionIDs)


	def _initExternalExchange(self, externalExchangedMolecules):
		"""Create external (media) exchange reactions."""

		externalMoleculeIDs = []
		externalExchangeIDs = []

		for moleculeID in externalExchangedMolecules:
			exchangeID = self._generatedID_externalExchange.format(moleculeID)

			# NOTE: The convention, if I am not mistaken, is to define
			# exchanges as pointing out of the system, even though it is common
			# to think of exchanges as inputs.  Regardless this choice should
			# have no impact outside of this class.

			self._solver.flowMaterialCoeffIs(
				exchangeID,
				moleculeID,
				-1
				)

			externalMoleculeIDs.append(moleculeID)
			externalExchangeIDs.append(exchangeID)
			self._specialFluxIDsSet.add(exchangeID)

		self._externalMoleculeIDs = tuple(externalMoleculeIDs)
		self._externalExchangeIDs = tuple(externalExchangeIDs)


	def _initObjectiveEquivalents(self, objective):
		"""Create pseudo-reactions that convert molecules into their fractional
		objective equivalents.  The objectiveType determines how these
		fractions are used."""

		for moleculeID in sorted(objective):
			coeff = objective[moleculeID]
			if coeff == 0:
				raise FBAError("Invalid objective coefficient - must be non-zero")

			pseudoFluxID = self._generatedID_moleculesToEquivalents.format(moleculeID)

			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				pseudoFluxID,
				moleculeID,
				-coeff
				)

			self._solver.flowMaterialCoeffIs(
				pseudoFluxID,
				objectiveEquivID,
				+1
				)

			# Objective molecules are output molecules
			if moleculeID in self._outputMoleculeIDs:
				i = self._outputMoleculeIDs.index(moleculeID)
			else:
				self._outputMoleculeIDs.append(moleculeID)
				self._outputMoleculeCoeffs.append(dict())
				i = len(self._outputMoleculeIDs) - 1

			self._outputMoleculeCoeffs[i][pseudoFluxID] = -coeff


	def _initObjectiveStandard(self, objective):
		"""Create the pseudo-reaction for the standard biomass objective.  In
		the standard objective, all molecules must be created/destroyed in
		prescribed ratios."""

		self._initObjectiveEquivalents(objective)

		for moleculeID in objective.viewkeys():
			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				self._standardObjectiveReactionName,
				objectiveEquivID,
				-1
				)

		self._solver.flowObjectiveCoeffIs(
			self._standardObjectiveReactionName,
			+1
			)


	def _initObjectiveFlexible(self, objective, objectiveParameters):
		"""Create the abstractions needed for the flexFBA objective.  In brief,
		flexFBA permits partial biomass objective satisfaction for individual
		molecules if network disruptions inhibit molecule production."""

		self._initObjectiveEquivalents(objective)

		# Load parameters
		leadingMoleculeID = objectiveParameters["leading molecule ID"]

		if not objective.has_key(leadingMoleculeID):
			raise FBAError("flexFBA leading molecule must be in the objective")

		fractionalDifferenceWeight = objectiveParameters["gamma"]

		if fractionalDifferenceWeight < 0:
			raise FBAError("flexFBA gamma paramter must be nonnegative")

		biomassSatisfactionWeight = objectiveParameters["beta"]

		if biomassSatisfactionWeight < 0:
			raise FBAError("flexFBA beta paramter must be nonnegative")

		if any(coeff < 0 for coeff in objective.viewvalues()):
			warnings.warn("flexFBA is not designed to use negative biomass coefficients")

		# Add biomass to objective
		self._solver.flowObjectiveCoeffIs(
			self._standardObjectiveReactionName,
			biomassSatisfactionWeight
			)

		# Create fraction and biomass outputs
		for moleculeID in objective.viewkeys():
			fractionID = self._generatedID_moleculeEquivalents.format(moleculeID)

			# Biomass out
			self._solver.flowMaterialCoeffIs(
				self._standardObjectiveReactionName,
				fractionID,
				-1
				)

			# Fraction out
			fractionOutID = self._generatedID_fractionsOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				fractionOutID,
				fractionID,
				-1
				)

			if moleculeID == leadingMoleculeID:
				# Add leading molecule to objective
				self._solver.flowObjectiveCoeffIs(
					fractionOutID,
					+1
					)

		# Create fraction differences (leading - other), used in objective and constraints
		leadingMoleculeToFractionID = self._generatedID_moleculesToEquivalents.format(leadingMoleculeID)

		for moleculeID in objective.viewkeys():
			if moleculeID == leadingMoleculeID:
				continue

			fractionDifferenceLeadingID = self._generatedID_fractionalDifferenceLeading.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				leadingMoleculeToFractionID,
				fractionDifferenceLeadingID,
				+1
				)

			moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				moleculeToFractionID,
				fractionDifferenceLeadingID,
				-1
				)

			fractionDifferenceLeadingOutID = self._generatedID_fractionalDifferenceLeadingOut.format(moleculeID)

			self._solver(
				fractionDifferenceLeadingOutID,
				fractionDifferenceLeadingID,
				-1
				)

			self._solver.flowObjectiveCoeffIs(
				fractionDifferenceLeadingOutID,
				-fractionalDifferenceWeight
				)

		# Create biomass differences (fraction - biomass), used in constraints

		for moleculeID in objective.viewkeys():
			fractionDifferenceBiomassID = self._generatedID_fractionalDifferenceBiomass.format(moleculeID)

			moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				moleculeToFractionID,
				fractionDifferenceBiomassID,
				+1
				)

			self._solver.flowMaterialCoeffIs(
				fractionDifferenceBiomassID,
				self._standardObjectiveReactionName,
				-1
				)

			fractionDifferenceBiomassOutID = self._generatedID_fractionalDifferenceBiomassOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				fractionDifferenceBiomassOutID,
				fractionDifferenceBiomassID,
				-1
				)


	def _initObjectivePools(self, objective):
		"""Create the abstractions needed for FBA with pools.  The objective is
		to minimize the distance between the current metabolite level and some
		target level, as defined in the objective."""

		self._initObjectiveEquivalents(objective)

		if any(coeff < 0 for coeff in objective.viewvalues()):
			raise FBAError("FBA with pools is not designed to use negative biomass coefficients")

		self._solver.maximizeObjective(False)
		self._forceInternalExchange = True

		# By forcing a column to be at unity, we can keep the definition of
		# the problem as b=Av where b=0.

		self._solver.flowLowerBoundIs(
			self._forcedUnityColName,
			+1
			)

		self._solver.flowUpperBoundIs(
			self._forcedUnityColName,
			+1
			)

		# Minimizing an absolute value requires splitting the term into two,
		# one for the positive values and one for the negative.

		for moleculeID in sorted(objective):
			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

			# Add the forced -1 term so that we can define x_i = f_i - 1

			self._solver.flowMaterialCoeffIs(
				self._forcedUnityColName,
				objectiveEquivID,
				-1
				)

			# Add the term for when the flux out is below the expected value

			belowUnityID = self._generatedID_fractionBelowUnityOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				belowUnityID,
				objectiveEquivID,
				+1
				)

			self._solver.flowObjectiveCoeffIs(
				belowUnityID,
				+1
				)

			# Add the term for when the flux out is above the expected value
			aboveUnityID = self._generatedID_fractionAboveUnityOut.format(moleculeID)

			self._solver.flowMaterialCoeffIs(
				aboveUnityID,
				objectiveEquivID,
				-1
				)

			self._solver.flowObjectiveCoeffIs(
				aboveUnityID,
				+1
				)

	def _initObjectiveMOMA(self, objective, objectiveParameters=None):
		""" Given a dict of reaction_name:rate (objective), attempts to
			minimize the distance between fluxes and those rates.
		If given, reactions in the list fixedReactionNames (which must be
			included in objective) is exactly at its specified rate.
		Classically, fixedReactionNames is the biomass reaction, and objective
			contains a kinetically-predicted flux distribution
		"""

		if objectiveParameters is not None and "fixedReactionNames" in objectiveParameters:
			fixedReactionNames = objectiveParameters["fixedReactionNames"]
		else:
			fixedReactionNames = []

		# Make single-string arguments into list
		if isinstance(fixedReactionNames, str):
			fixedReactionNames = [fixedReactionNames]

		# This is a minimization objective problem
		self._solver.maximizeObjective(False)

		nonObjectiveReactions = set()
		for reactionName in fixedReactionNames:

			# Check that fixed reactions are in the objective dict
			if reactionName not in objective:
				nonObjectiveReactions.add(reactionName)
				continue

		if len(nonObjectiveReactions) > 0:
			raise FBAError("All fixed reactions must have an entry in the objective dict. No entry found for {}.".format(nonObjectiveReactions))

		self._errorFluxNames = set()

		for reactionID in objective:

			if reactionID not in self.reactionStoich:
				raise FBAError("{} is not in the reaction network.".format(reactionID))

			# Fix reaction to target flux
			self.minReactionFluxIs(reactionID, objective[reactionID])
			self.maxReactionFluxIs(reactionID, objective[reactionID])

			# If reaction is not in the fixed reactions set, create relaxation fluxes for it
			if reactionID not in fixedReactionNames:

				## Above
				# Add a pseudoreaction to allow the flux to be above its target
				overTargetFlux = self._generatedID_amountOver.format(reactionID)
				for materialID, coeff in self.reactionStoich[reactionID].iteritems():
					self._solver.flowMaterialCoeffIs(
						overTargetFlux,
						materialID,
						coeff
						)
				self._specialFluxIDsSet.add(overTargetFlux)

				# The objective is to mimimize this relaxation
				self._solver.flowObjectiveCoeffIs(
					overTargetFlux,
					+1
					)

				## Below
				# Add a pseudoreaction to allow the flux to be below its target
				underTargetFlux = self._generatedID_amountUnder.format(reactionID )
				for materialID, coeff in self.reactionStoich[reactionID].iteritems():
					self._solver.flowMaterialCoeffIs(
						underTargetFlux,
						materialID,
						-coeff
						)
				self._specialFluxIDsSet.add(underTargetFlux)

				# The relaxation cannot allow overall negative flux
				self.maxReactionFluxIs(underTargetFlux, objective[reactionID])

				# The objective is to mimimize this relaxation
				self._solver.flowObjectiveCoeffIs(
					underTargetFlux,
					+1
					)

				self._errorFluxNames.add(reactionID)


	def _initInternalExchange(self, internalExchangedMolecules):
		"""Create internal (byproduct) exchange reactions."""

		internalMoleculeIDs = []

		if internalExchangedMolecules is not None:
			for moleculeID in internalExchangedMolecules:
				exchangeID = self._generatedID_internalExchange.format(moleculeID)

				self._solver.flowMaterialCoeffIs(
					exchangeID,
					moleculeID,
					-1
					)

				internalMoleculeIDs.append(moleculeID)
				self._specialFluxIDsSet.add(exchangeID)

				# TODO: functionalize
				try:
					i = self._outputMoleculeIDs.index(moleculeID)

				except ValueError:
					self._outputMoleculeIDs.append(moleculeID)
					self._outputMoleculeCoeffs.append(dict())
					i = len(self._outputMoleculeIDs) - 1

				self._outputMoleculeCoeffs[i][exchangeID] = -1

		self._internalMoleculeIDs = tuple(internalMoleculeIDs)


	def _initEnzymeConstraints(self, reactionEnzymes, reactionRates):
		"""Create abstractions needed to constrain metabolic reactions by
		enzyme availability.

		There are two types of enzyme restrictions.  If the catalytic rate is
		unknown, any non-zero level of the enzyme allows the reaction to
		proceed.  This is a "boolean" constraint.  If the catalytic rate is
		known, then reactions may proceed up to their kinetic limit.  Reactions
		can share enzymes.  There is currently no support for reactions with
		multiple annotated enzymes."""

		self._rateConstrainedEnzymeIDs = []

		if reactionEnzymes is not None:

			## First create the pseudometabolites and enzyme usage columns
			self._enzymeIDs = tuple(set(reactionEnzymes.values()))

			for enzymeID in self._enzymeIDs:
				# Create pseudometabolite and flux for rate-constrained
				enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)
				enzymeUsageRateID = self._generatedID_enzymeUsageRateConstrained.format(enzymeID)

				self._solver.flowMaterialCoeffIs(
					enzymeUsageRateID,
					enzymeEquivalentRateID,
					+1
					)

				# Create pseudometabolite and flux for bool-constrained
				enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)
				enzymeUsageBoolID = self._generatedID_enzymeUsageBoolConstrained.format(enzymeID)

				self._solver.flowMaterialCoeffIs(
					enzymeUsageBoolID,
					enzymeEquivalentBoolID,
					+1
					)


			for reactionID, enzymeID in reactionEnzymes.viewitems():
				if reactionRates is not None and reactionRates.has_key(reactionID):
					reactionRate = reactionRates[reactionID]

					if reactionRate <= 0:
						raise FBAError("Reaction rates must be positive ({}, {})".format(reactionID, reactionRate))

					enzymesPerReaction = -1/reactionRate
					enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)

					self._solver.flowMaterialCoeffIs(
						reactionID,
						enzymeEquivalentRateID,
						enzymesPerReaction
						)

					self._rateConstrainedEnzymeIDs.append(enzymeID)


				else:
					enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)

					self._solver.flowMaterialCoeffIs(
						reactionID,
						enzymeEquivalentBoolID,
						-1
						)


	def _initExchangeMass(self, externalExchangedMolecules, moleculeMasses, secretionPenaltyCoeff):
		"""Create mass accumulation abstractions.

		Tracking the mass entering the system through metabolism is crucial for
		insuring closure. It can also be used to constrain the maximal rate of
		growth."""

		if moleculeMasses is not None:
			self._solver.flowMaterialCoeffIs(
				self._massExchangeOutName,
				self._massExchangeID,
				-1
				)

			for moleculeID in externalExchangedMolecules:
				exchangeFluxID = self._generatedID_externalExchange.format(moleculeID)

				try:
					moleculeMass = moleculeMasses[moleculeID]

				except KeyError:
					raise FBAError("You must provide masses for all molecules in externalExchangedMolecules")

				self._solver.flowMaterialCoeffIs(
					exchangeFluxID,
					self._massExchangeID,
					-moleculeMass # NOTE: negative because exchange fluxes point out
					)

				if secretionPenaltyCoeff is not None:
					# Limit secretion/export
					absID = self._generatedID_externalExchangeAbs.format(moleculeID)
					posExchangeID = self._generatedID_externalExchangePos.format(moleculeID)
					negExchangeID = self._generatedID_externalExchangeNeg.format(moleculeID)

					self._solver.flowMaterialCoeffIs(
						exchangeFluxID,
						absID,
						moleculeMass
						)

					self._solver.flowMaterialCoeffIs(
						posExchangeID,
						absID,
						-1
						)

					self._solver.flowMaterialCoeffIs(
						negExchangeID,
						absID,
						+1
						)

					self._solver.flowObjectiveCoeffIs(
						posExchangeID,
						secretionPenaltyCoeff
					)


	def _initMaintenance(self, maintenanceCostGAM, maintenanceReaction):
		"""Create growth-associated maintenance abstractions.

		Two maintenance costs are typically associated with FBA; growth-
		associated maintenance is the energetic cost of increasing cell mass by
		a certain amount.  (Contrast non-growth-associated maintenance, which
		is a fixed energetic cost regardless of mass accumulation.)
		"""

		if (maintenanceCostGAM is None) and (maintenanceReaction is None):
			return

		if (maintenanceCostGAM is None) ^ (maintenanceReaction is None):
			raise FBAError("Must pass all or none of maintenanceCostGAM, maintenanceReaction")


		# TODO: check that the mass flux stuff exists

		# computed mass output produces "GAM reactions"...

		self._solver.flowMaterialCoeffIs(
			self._massExchangeOutName,
			self._pseudometaboliteGAM,
			maintenanceCostGAM
			)

		# ... which are consumed in a seperate flux

		self._solver.flowMaterialCoeffIs(
			self._reactionID_GAM,
			self._pseudometaboliteGAM,
			-1
			)

		for moleculeID, stoichCoeff in maintenanceReaction.viewitems():
			self._solver.flowMaterialCoeffIs(
				self._reactionID_GAM,
				moleculeID,
				stoichCoeff
				)

			self._solver.flowMaterialCoeffIs(
				self._reactionID_NGAM,
				moleculeID,
				stoichCoeff
				)

			self._solver.flowMaterialCoeffIs(
				self._reactionID_polypeptideElongationEnergy,
				moleculeID,
				stoichCoeff
				)

		self._specialFluxIDsSet.add(self._reactionID_GAM)
		self._specialFluxIDsSet.add(self._reactionID_NGAM)
		self._specialFluxIDsSet.add(self._reactionID_polypeptideElongationEnergy)


	def _buildEqConst(self):
		try:
			self._solver.buildEqConst()
		except AttributeError:
			return


	# Constraint setup

	# NOTE: I've used the nonspecific term "levels" since these could be
	# mole-concentration, number-concentration, or counts, depending on the
	# formulation of the problem.  All that matters is that initialization
	# parameters have consistent units.

	def externalMoleculeIDs(self):
		return self._externalMoleculeIDs


	def externalMoleculeLevelsIs(self, levels):
		levels_array = np.empty(len(self._externalMoleculeIDs))
		levels_array[:] = levels

		for moleculeID, level in izip(self._externalMoleculeIDs, levels_array):
			flowID = self._generatedID_externalExchange.format(moleculeID)

			if level < 0:
				print "Setting a negative external molecule level - be sure this is intended behavior."

				self._solver.flowUpperBoundIs(
					flowID,
					-level
					)
			else:
				self._solver.flowLowerBoundIs(
					flowID,
					-level
					)


	def internalMoleculeIDs(self):
		return self._internalMoleculeIDs


	def internalMoleculeLevelsIs(self, levels):
		levels_array = np.empty(len(self._internalMoleculeIDs))
		levels_array[:] = levels

		if (levels_array < 0).any():
			raise InvalidBoundaryError("Negative molecule levels not allowed")

		for moleculeID, level in izip(self._internalMoleculeIDs, levels_array):
			flowID = self._generatedID_internalExchange.format(moleculeID)

			self._solver.flowLowerBoundIs(
				flowID,
				-level
				)

			if self._forceInternalExchange:
				self._solver.flowUpperBoundIs(
					flowID,
					-level
					)


	def enzymeIDs(self):
		return self._enzymeIDs


	def enzymeLevelsIs(self, levels):
		if not hasattr(self, "_enzymeIDs"):
			return

		levels_array = np.empty(len(self._enzymeIDs))
		levels_array[:] = levels

		if (levels_array < 0).any():
			raise InvalidBoundaryError("Negative enzyme levels not allowed")

		for enzymeID, level in izip(self._enzymeIDs, levels_array):
			if enzymeID in self._rateConstrainedEnzymeIDs:
				# Rate-constrained
				flowID = self._generatedID_enzymeUsageRateConstrained.format(enzymeID)

				self._solver.flowUpperBoundIs(
					flowID,
					level
					)

			else:
				# Boolean-constrained (enzyme w/o an annotated rate)
				flowID = self._generatedID_enzymeUsageBoolConstrained.format(enzymeID)

				self._solver.flowUpperBoundIs(
					flowID,
					np.inf if level > 0 else 0
					)


	def reactionIDs(self):
		return np.array(self._reactionIDs)


	def maxReactionFluxIs(self, reactionID, maxFlux, raiseForReversible = True):
		if maxFlux < 0:
			raise InvalidBoundaryError("Maximum reaction flux must be at least 0")

		if reactionID not in self._reactionIDsSet and reactionID not in self._specialFluxIDsSet:
			raise InvalidBoundaryError("Unable to set max reaction flux: reaction '%s' not recognized." % (reactionID))

		# if maxFlux < self._lowerBound[colIndex]:
		# 	raise InvalidBoundaryError("Maximum reaction flux must be greater than or equal to the minimum flux")

		reverseReactionID = self._generatedID_reverseReaction.format(reactionID)

		if raiseForReversible and reverseReactionID in self._reactionIDs:
			raise FBAError((
				"Setting the maximum reaction flux is ambiguous since " +
				"reaction {} has both a forward [{}] and reverse [{}] " +
				"component.  Call this method with argument " +
				"raiseForReversible = False if this is intended behavior."
				).format(reactionID, reactionID, reverseReactionID))

		self._solver.flowUpperBoundIs(
			reactionID,
			maxFlux
			)


	def minReactionFluxIs(self, reactionID, minFlux, raiseForReversible = True):
		if minFlux < 0:
			raise InvalidBoundaryError("Minimum reaction flux must be at least 0")

		if reactionID not in self._reactionIDsSet and reactionID not in self._specialFluxIDsSet:
			raise InvalidBoundaryError("Unable to set min reaction flux: reaction '%s' not recognized." % (reactionID))

		# if minFlux > self._upperBound[colIndex]:
		# 	raise InvalidBoundaryError("Minimum reaction flux must be less than or equal to the maximum flux")

		reverseReactionID = self._generatedID_reverseReaction.format(reactionID)

		if raiseForReversible and reverseReactionID in self._reactionIDs:
			raise FBAError((
				"Setting the minimum reaction flux is ambiguous since " +
				"reaction {} has both a forward [{}] and reverse [{}] " +
				"component.  Call this method with argument " +
				"raiseForReversible = False if this is intended behavior."
				).format(reactionID, reactionID, reverseReactionID))

		self._solver.flowLowerBoundIs(
			reactionID,
			minFlux
			)

	def setMaxReactionFluxes(self, reactionIDs, reactionRates, raiseForReversible=True):
		if len(reactionIDs) != len(reactionRates):
			raise Exception("There must be equal numbers of reactionIDs and rates to set limits.")

		for idx, reactionID in enumerate(reactionIDs):
			self.maxReactionFluxIs(reactionID, reactionRates[idx], raiseForReversible)

	def setMinReactionFluxes(self, reactionIDs, reactionRates, raiseForReversible=True):
		if len(reactionIDs) != len(reactionRates):
			raise Exception("There must be equal numbers of reactionIDs and rates to set limits.")

		for idx, reactionID in enumerate(reactionIDs):
			self.minReactionFluxIs(reactionID, reactionRates[idx], raiseForReversible)

	def setpointIs(self, moleculeID, coeff):
		if moleculeID not in self._outputMoleculeIDs:
			raise FBAError(
				"setpointIs() only allows for modification of setpoint values, " +
				"not adding new ones. %s is an unrecognized molecule" % moleculeID
				)

		pseudoFluxID = self._generatedID_moleculesToEquivalents.format(moleculeID)

		objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)

		self._solver.flowMaterialCoeffIs(
			pseudoFluxID,
			moleculeID,
			-coeff
			)

		i = self._outputMoleculeIDs.index(moleculeID)
		self._outputMoleculeCoeffs[i][pseudoFluxID] = -coeff

	def maxMassAccumulatedIs(self, maxAccumulation):
		self._solver.flowUpperBoundIs(
			self._massExchangeOutName,
			maxAccumulation
			)

	# Output

	def outputMoleculeIDs(self):
		return tuple(self._outputMoleculeIDs)


	def outputMoleculeLevelsChange(self):
		# This is essentially a dot product, need to profile to make sure this
		# isn't horribly slow

		change = np.zeros(len(self._outputMoleculeIDs))

		for i, outputMoleculeID in enumerate(self._outputMoleculeIDs):
			for reactionID, coeff in self._outputMoleculeCoeffs[i].viewitems():
				change[i] += self._solver.flowRates(reactionID) * coeff

		return -change

	def externalExchangeFluxes(self):
		return self._solver.flowRates(self._externalExchangeIDs)

	def externalExchangeFlux(self, moleculeID):
		fluxID = self._generatedID_externalExchange.format(moleculeID)
		if fluxID not in self._externalExchangeIDs:
			raise FBAError("{} is not a known externally exchanged molecule.".format(moleculeID))
		return -self._solver.flowRates(fluxID)

	# def internalExchangeFlux(self, moleculeID):
	# 	if moleculeID not in self._fluxIndex:
	# 		raise FBAError("{} is not a known internally exchanged molecule.".format(moleculeID))
	# 	return -self._solutionFluxes[
	# 		self._fluxIndex(self._generatedID_internalExchange.format(moleculeID))
	# 		]

	def reactionFlux(self, reactionID):
		return self._solver.flowRates(reactionID)

	def reactionFluxes(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self._reactionIDs
		return self._solver.flowRates(reactionIDs)

	def rowDualValues(self, moleculeIDs):
		return self._solver.rowDualValues(moleculeIDs)

	def columnDualValues(self, moleculeIDs):
		return self._solver.columnDualValues(moleculeIDs)

	def biomassReactionFlux(self):
		if self.objectiveType not in ("standard", "flexible", "moma"):
			raise FBAError("There is no biomass reaction for this objective type ({})".format(self.objectiveType))
		return self._solver.flowRates(self._standardObjectiveReactionName)[0]

	def objectiveValue(self):
		return self._solver.objectiveValue()

	def errorFlux(self, reactionID):
		if self.objectiveType is not "moma":
			raise FBAError("Error fluxes only apply for MOMA.")
		if reactionID not in self._errorFluxNames:
			raise FBAError("{} does not have an error flux.".format(reactionID))
		errorAbove = self.reactionFlux(self._generatedID_amountOver.format(reactionID))
		errorBelow = self.reactionFlux(self._generatedID_amountUnder.format(reactionID))
		return errorAbove - errorBelow

	def errorFluxes(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self.errorFluxNames()
		values = np.zeros(len(reactionIDs))
		for idx, reactionID in enumerate(reactionIDs):
			values[idx] = self.errorFlux(reactionID)
		return values

	def errorAdjustedReactionFluxes(self, reactionIDs=None):
		if reactionIDs is None:
			reactionIDs = self.errorFluxNames()
		return self.errorFluxes(reactionIDs) + self.reactionFluxes(reactionIDs)

	def errorFluxNames(self):
		if self.objectiveType is not "moma":
			raise FBAError("Error fluxes only apply for MOMA.")
		else:
			return sorted(self._errorFluxNames)

	def getArrayBasedModel(self):
		return {
		"S_matrix":self._solver.getSMatrix(),
		"Reactions":self._solver.getFlowNames(),
		"Metabolites":self._solver.getMaterialNames(),
		"Upper bounds":self._solver.getUpperBounds(),
		"Lower bounds":self._solver.getLowerBounds(),
		}

	def massAccumulated(self):
		return self._solver.flowRates(self._massExchangeOutName)
