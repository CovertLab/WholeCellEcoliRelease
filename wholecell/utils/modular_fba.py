#!/usr/bin/env python

"""
@author: John Mason
@organization: Covert Lab, Department of Bioengineering, Stanford University
@date: Created 7/14/2014
"""

from __future__ import division

from collections import defaultdict
from itertools import izip
import warnings

import numpy as np
import cvxopt
import cvxopt.solvers

from wholecell.utils import units

# Exceptions

class FBAException(Exception):
	pass


class AlreadyExistsException(FBAException):
	pass


class DoesNotExistException(FBAException):
	pass


class InvalidBoundaryException(FBAException):
	pass

# Classes

class FluxBalanceAnalysis(object):
	""" FluxBalanceAnalysis

	Solver for various FBA implementations.

	
	Required arguments:

	- reactionStoich, a dict of strings:dicts (reactionID:reaction stoich)
		Each value in the dict is a dict of molecule ID to stoichiometry pairs

	- externalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- objective, a dict of strings:floats (moleculeID:objective value)
		The meaning and usage of the objective will vary depending on the 
		formulation of FBA desired.

	
	Optional arguments (set to None for default behavior):

	- objectiveType, a string
		"standard": standard FBA objective (default)
		"flexible": flexFBA
		"pools": similar to FBA; optimizes towards desired pool concentrations

	- objectiveParameters, a dict
		Keys are specific to the FBA implementation.

	- internalExchangedMolecules, an iterable of strings (moleculeIDs)
		Every provided ID will be set up with an exchange flux.

	- reversibleReactions, a list of strings (reactionIDs for reversible reactions)

	- reactionEnzymes, a dict of strings:strings (reactionID:enzymeID)
	
	- reactionRates, a dict of strings:floats (reactionID:catalytic rate constant * dt)
		Used to set up the pseudo metabolites and boundary constraints needed
		for limiting reactions by enzyme counts.

	- moleculeMasses, a dict of floats (moleculeID:mass)
		Used in computing the net mass into the system.  Only needed and used 
		for moleculeIDs in externalExchangedMolecules.

	
	Caveats:
	
	There is no strict type checking, despite what the above may imply.

	During initialization, an exception will be raised if a reference is made 
	to an unutilized metabolite/enzyme/etc as described by the reaction 
	network.

	"""

	# Format strings for autogenerated IDs

	## Reverse reactions
	_generatedID_reverseReaction = "{} (reverse)"

	## Exchange fluxes
	_generatedID_externalExchange = "{} external exchange"
	_generatedID_internalExchange = "{} internal exchange"

	## Objective
	_generatedID_moleculesToEquivalents = "molecules of {} to fractional objective equivalents"
	_generatedID_moleculeEquivalents = "fractional objective equivalent for {}"

	## Rate-constrained enzymes
	_generatedID_enzymeEquivRateConstrained = "{} equivalent (rate-constrained)"
	_generatedID_enzymeUsageRateConstrained = "{} usage (rate-constrained)"

	## Bool-constrained enzymes
	_generatedID_enzymeEquivBoolConstrained = "{} equivalent (bool-constrained)"
	_generatedID_enzymeUsageBoolConstrained = "{} usage (bool-constrained)"

	## Flex FBA
	_generatedID_fractionalDifferenceLeading = "difference between fractional objective equivalents of leading molecule and {}"
	_generatedID_fractionalDifferenceBiomass = "difference between fractional objective equivalents of {} and biomass objective"

	_generatedID_fractionsOut = "fractional objective equivalents of {} out"
	_generatedID_fractionalDifferenceLeadingOut = "difference between fractional objective equivalents of leading molecule and {} out"
	_generatedID_fractionalDifferenceBiomassOut = "difference between fractional objective equivalents of {} and biomass objective out"

	## Pools FBA

	_generatedID_fractionBelowUnityOut = "fraction {} below unity, out"
	_generatedID_fractionAboveUnityOut = "fraction {} above unity, out"

	# Default values, for clarity
	_lowerBoundDefault = 0
	_upperBoundDefault = np.inf

	_standardObjectiveReactionName = "Standard biomass objective reaction"
	_massOutName = "Mass out"

	_forcedUnityColName = "Column forced at unity"

	_numericalInfinity = 1e6 # used to constrain the solver to finite values

	# Initialization

	def __init__(self, reactionStoich, externalExchangedMolecules, objective,
			objectiveType = None, objectiveParameters = None,
			internalExchangedMolecules = None, reversibleReactions = None, 
			reactionEnzymes = None, reactionRates = None, moleculeMasses = None):

		# Set up attributes

		self._rowNames = []
		self._colNames = []

		# Set up running values for initialization

		## Used for creating the sparse matrix
		# TODO: methods for creating/manipulating rows and cols (and values)
		# using their names instead of their indexes
		self._rowIndexes = []
		self._colIndexes = []
		self._values = []

		## Used for objective and bounds
		self._objIndexes = []
		self._objValues = []

		self._lowerBoundIndexes = []
		self._lowerBoundValues = []

		self._upperBoundIndexes = []
		self._upperBoundValues = []

		self._maximizeObjective = True
		self._forceInternalExchange = False

		## Output calculations
		self._outputMoleculeIndexes = []
		self._outputReactionIndexes = []

		# Set up reversible reactions
		if reversibleReactions is not None:
			for reactionID in reversibleReactions:
				reverseReactionID = self._generatedID_reverseReaction.format(reactionID)
				
				reactionStoich[reverseReactionID] = {
					moleculeID:-stoichCoeff
					for moleculeID, stoichCoeff in reactionStoich[reactionID].viewitems()
					}

				if reactionEnzymes is not None and reactionEnzymes.has_key(reactionID):
					reactionEnzymes[reverseReactionID] = reactionEnzymes[reactionID]

				if reactionRates is not None and reactionRates.has_key(reactionID):
					reactionRates[reverseReactionID] = reactionRates[reactionID]

		# Call indivdual initialization methods

		self._initReactionNetwork(reactionStoich)
		self._initExternalExchange(externalExchangedMolecules)

		self._initObjectiveEquivalents(objective)

		if objectiveType is None or objectiveType == "standard":
			self._initObjectiveStandard(objective)

		elif objectiveType == "flexible":
			self._initObjectiveFlexible(objective, objectiveParameters)

		elif objectiveType == "pools":
			self._initObjectivePools(objective)

			if internalExchangedMolecules is not None:
				raise FBAException(
					"Internal exchange molecules are automatically defined when using objectiveType = \"pools\""
					)

			internalExchangedMolecules = objective.keys()

		else:
			raise FBAException("Unrecognized objectiveType: {}".format(objectiveType))

		self._initInternalExchange(internalExchangedMolecules)

		self._initEnzymeConstraints(reactionEnzymes, reactionRates)

		self._initMass(externalExchangedMolecules, moleculeMasses)

		# Finalize

		self._finalizeMisc()
		self._finalizeMatrices()

		# Set up values that will change between runs

		self.externalMoleculeLevelsIs(0)
		self.internalMoleculeLevelsIs(0)
		self.enzymeLevelsIs(0)


	def _initReactionNetwork(self, reactionStoich):
		""" Create the reaction network, initializing molecules and biochemical
		reactions. """
		
		reactionIndexes = []

		for reactionID, stoichiometry in reactionStoich.viewitems():
			colIndex = self._colNew(reactionID)

			for moleculeID, stoichCoeff in stoichiometry.viewitems():
				rowIndex = self._rowIndex(moleculeID, True)

				self._rowIndexes.append(rowIndex)
				self._colIndexes.append(colIndex)
				self._values.append(stoichCoeff)

			reactionIndexes.append(colIndex)

		self._reactionIndexes = np.array(reactionIndexes)


	def _initExternalExchange(self, externalExchangedMolecules):
		"""Create external (media) exchange reactions."""

		externalExchangeIndexes = []
		externalMoleculeIDs = []

		for moleculeID in externalExchangedMolecules:
			exchangeID = self._generatedID_externalExchange.format(moleculeID)

			colIndex = self._colNew(exchangeID)
			rowIndex = self._rowIndex(moleculeID)

			# NOTE: The convention, if I am not mistaken, is to define 
			# exchanges as pointing out of the system, even though it is common
			# to think of exchanges as inputs.  Regardless this choice should 
			# have no impact outside of this class.

			self._rowIndexes.append(rowIndex)
			self._colIndexes.append(colIndex)
			self._values.append(-1)

			externalExchangeIndexes.append(colIndex)
			externalMoleculeIDs.append(moleculeID)

		self._externalExchangeIndexes = np.array(externalExchangeIndexes, np.int64)
		self._externalMoleculeIDs = tuple(externalMoleculeIDs)


	def _initObjectiveEquivalents(self, objective):
		"""Create pseudo-reactions that convert molecules into their fractional
		objective equivalents.  The objectiveType determines how these 
		fractions are used."""

		for moleculeID, coeff in objective.viewitems():
			if coeff == 0:
				raise FBAException("Invalid objective coefficient - must be non-zero")

			molecule_rowIndex = self._rowIndex(moleculeID)

			pseudoFluxID = self._generatedID_moleculesToEquivalents.format(moleculeID)
			colIndex = self._colNew(pseudoFluxID)

			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)
			objectiveEquiv_rowIndex = self._rowNew(objectiveEquivID)

			self._rowIndexes.append(molecule_rowIndex)
			self._colIndexes.append(colIndex)
			self._values.append(-coeff)

			self._rowIndexes.append(objectiveEquiv_rowIndex)
			self._colIndexes.append(colIndex)
			self._values.append(+1)

			self._outputMoleculeIndexes.append(molecule_rowIndex)

			self._outputReactionIndexes.append(colIndex)


	def _initObjectiveStandard(self, objective):
		"""Create the pseudo-reaction for the standard biomass objective.  In 
		the standard objective, all molecules must be created/destroyed in 
		prescribed ratios."""

		colIndex = self._colNew(self._standardObjectiveReactionName)

		for moleculeID in objective.viewkeys():
			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)
			objectiveEquiv_rowIndex = self._rowIndex(objectiveEquivID)

			self._rowIndexes.append(objectiveEquiv_rowIndex)
			self._colIndexes.append(colIndex)
			self._values.append(-1)

		self._objIndexes.append(colIndex)
		self._objValues.append(+1)


	def _initObjectiveFlexible(self, objective, objectiveParameters):
		"""Create the abstractions needed for the flexFBA objective.  In brief,
		flexFBA permits partial biomass objective satisfaction for individual
		molecules if network disruptions inhibit molecule production."""

		# Load parameters
		leadingMoleculeID = objectiveParameters["leading molecule ID"]

		if not objective.has_key(leadingMoleculeID):
			raise FBAException("flexFBA leading molecule must be in the objective")

		fractionalDifferenceWeight = objectiveParameters["gamma"]

		if fractionalDifferenceWeight < 0:
			raise FBAException("flexFBA gamma paramter must be nonnegative")

		biomassSatisfactionWeight = objectiveParameters["beta"]

		if biomassSatisfactionWeight < 0:
			raise FBAException("flexFBA beta paramter must be nonnegative")

		biomass_colIndex = self._colNew(self._standardObjectiveReactionName)

		if any(coeff < 0 for coeff in objective.viewvalues()):
			warnings.warn("flexFBA is not designed to use negative biomass coefficients")

		# Add biomass to objective
		self._objIndexes.append(biomass_colIndex)
		self._objValues.append(biomassSatisfactionWeight)

		# Create fraction and biomass outputs
		for moleculeID in objective.viewkeys():
			fractionID = self._generatedID_moleculeEquivalents.format(moleculeID)
			fraction_rowIndex = self._rowIndex(fractionID)

			# Biomass out
			self._rowIndexes.append(fraction_rowIndex)
			self._colIndexes.append(biomass_colIndex)
			self._values.append(-1)

			# Fraction out
			fractionOutID = self._generatedID_fractionsOut.format(moleculeID)
			fractionOut_colIndex = self._colNew(fractionOutID)

			self._rowIndexes.append(fraction_rowIndex)
			self._colIndexes.append(fractionOut_colIndex)
			self._values.append(-1)

			if moleculeID == leadingMoleculeID:
				# Add leading molecule to objective
				self._objIndexes.append(fractionOut_colIndex)
				self._objValues.append(+1)

		# Create fraction differences (leading - other), used in objective and constraints
		leadingMoleculeToFractionID = self._generatedID_moleculesToEquivalents.format(leadingMoleculeID)
		leadingMoleculeToFraction_colIndex = self._colIndex(leadingMoleculeToFractionID)

		for moleculeID in objective.viewkeys():
			if moleculeID == leadingMoleculeID:
				continue

			fractionDifferenceLeadingID = self._generatedID_fractionalDifferenceLeading.format(moleculeID)
			fractionDifferenceLeading_rowIndex = self._rowNew(fractionDifferenceLeadingID)

			self._rowIndexes.append(fractionDifferenceLeading_rowIndex)
			self._colIndexes.append(leadingMoleculeToFraction_colIndex)
			self._values.append(+1)
			
			moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)
			moleculeToFraction_colIndex = self._colIndex(moleculeToFractionID)

			self._rowIndexes.append(fractionDifferenceLeading_rowIndex)
			self._colIndexes.append(moleculeToFraction_colIndex)
			self._values.append(-1)

			fractionDifferenceLeadingOutID = self._generatedID_fractionalDifferenceLeadingOut.format(moleculeID)
			fractionDifferenceLeadingOut_colIndex = self._colNew(fractionDifferenceLeadingOutID)

			self._rowIndexes.append(fractionDifferenceLeading_rowIndex)
			self._colIndexes.append(fractionDifferenceLeadingOut_colIndex)
			self._values.append(-1)

			self._objIndexes.append(fractionDifferenceLeadingOut_colIndex)
			self._objValues.append(-fractionalDifferenceWeight)

		# Create biomass differences (fraction - biomass), used in constraints

		for moleculeID in objective.viewkeys():
			fractionDifferenceBiomassID = self._generatedID_fractionalDifferenceBiomass.format(moleculeID)
			fractionDifferenceBiomass_rowIndex = self._rowNew(fractionDifferenceBiomassID)

			moleculeToFractionID = self._generatedID_moleculesToEquivalents.format(moleculeID)
			moleculeToFraction_colIndex = self._colIndex(moleculeToFractionID)

			self._rowIndexes.append(fractionDifferenceBiomass_rowIndex)
			self._colIndexes.append(moleculeToFraction_colIndex)
			self._values.append(+1)

			self._rowIndexes.append(fractionDifferenceBiomass_rowIndex)
			self._colIndexes.append(biomass_colIndex)
			self._values.append(-1)

			fractionDifferenceBiomassOutID = self._generatedID_fractionalDifferenceBiomassOut.format(moleculeID)
			fractionDifferenceBiomassOut_colIndex = self._colNew(fractionDifferenceBiomassOutID)

			self._rowIndexes.append(fractionDifferenceBiomass_rowIndex)
			self._colIndexes.append(fractionDifferenceBiomassOut_colIndex)
			self._values.append(-1)


	def _initObjectivePools(self, objective):
		"""Create the abstractions needed for FBA with pools.  The objective is
		to minimize the distance between the current metabolite level and some
		target level, as defined in the objective."""

		if any(coeff < 0 for coeff in objective.viewvalues()):
			raise FBAException("FBA with pools is not designed to use negative biomass coefficients")

		self._maximizeObjective = False
		self._forceInternalExchange = True

		# By forcing a column to be at unity, we can keep the definition of 
		# the problem as b=Av where b=0.

		forcedUnity_colIndex = self._colNew(self._forcedUnityColName)

		self._lowerBoundIndexes.append(forcedUnity_colIndex)
		self._lowerBoundValues.append(+1)

		self._upperBoundIndexes.append(forcedUnity_colIndex)
		self._upperBoundValues.append(+1)

		# Minimizing an absolute value requires splitting the term into two,
		# one for the positive values and one for the negative.

		for moleculeID in objective.viewkeys():
			objectiveEquivID = self._generatedID_moleculeEquivalents.format(moleculeID)
			objectiveEquiv_rowIndex = self._rowIndex(objectiveEquivID)

			# Add the forced -1 term so that we can define x_i = f_i - 1

			self._rowIndexes.append(objectiveEquiv_rowIndex)
			self._colIndexes.append(forcedUnity_colIndex)
			self._values.append(-1)

			# Add the term for when the flux out is below the expected value

			belowUnity_colIndex = self._colNew(
				self._generatedID_fractionBelowUnityOut.format(moleculeID)
				)

			self._rowIndexes.append(objectiveEquiv_rowIndex)
			self._colIndexes.append(belowUnity_colIndex)
			self._values.append(+1)

			self._objIndexes.append(belowUnity_colIndex)
			self._objValues.append(+1)

			# Add the term for when the flux out is above the expected value

			aboveUnity_colIndex = self._colNew(
				self._generatedID_fractionAboveUnityOut.format(moleculeID)
				)

			self._rowIndexes.append(objectiveEquiv_rowIndex)
			self._colIndexes.append(aboveUnity_colIndex)
			self._values.append(-1)

			self._objIndexes.append(aboveUnity_colIndex)
			self._objValues.append(+1)


	def _initInternalExchange(self, internalExchangedMolecules):
		"""Create internal (byproduct) exchange reactions."""

		internalExchangeIndexes = []
		internalMoleculeIDs = []

		if internalExchangedMolecules is not None:
			for moleculeID in internalExchangedMolecules:
				exchangeID = self._generatedID_internalExchange.format(moleculeID)

				colIndex = self._colNew(exchangeID)
				rowIndex = self._rowIndex(moleculeID)

				self._rowIndexes.append(rowIndex)
				self._colIndexes.append(colIndex)
				self._values.append(-1)

				internalExchangeIndexes.append(colIndex)
				internalMoleculeIDs.append(moleculeID)

				if rowIndex not in self._outputMoleculeIndexes:
					self._outputMoleculeIndexes.append(rowIndex)

				if colIndex not in self._outputReactionIndexes:
					self._outputReactionIndexes.append(colIndex)

		self._internalExchangeIndexes = np.array(internalExchangeIndexes, np.int64)
		self._internalMoleculeIDs = tuple(internalMoleculeIDs)


	def _initEnzymeConstraints(self, reactionEnzymes, reactionRates):
		"""Create abstractions needed to constrain metabolic reactions by 
		enzyme availability.

		There are two types of enzyme restrictions.  If the catalytic rate is 
		unknown, any non-zero level of the enzyme allows the reaction to
		proceed.  This is a "boolean" constraint.  If the catalytic rate is
		known, then reactions may proceed up to their kinetic limit.  Reactions
		can share enzymes.  There is currently no support for reactions with 
		multiple annotated enzymes."""

		enzymeUsageRateConstrainedIndexes = []
		enzymeUsageBoolConstrainedIndexes = []

		if reactionEnzymes is not None:

			## First create the pseudometabolites and enzyme usage columns
			self._enzymeIDs = tuple(set(reactionEnzymes.values()))

			for enzymeID in self._enzymeIDs:
				# Create pseudometabolite and flux for rate-constrained
				enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)
				enzymeEquivalentRate_rowIndex = self._rowNew(enzymeEquivalentRateID)

				enzymeUsageRateID = self._generatedID_enzymeUsageRateConstrained.format(enzymeID)
				enzymeUsageRate_colIndex = self._colNew(enzymeUsageRateID)

				self._rowIndexes.append(enzymeEquivalentRate_rowIndex)
				self._colIndexes.append(enzymeUsageRate_colIndex)
				self._values.append(+1)

				enzymeUsageRateConstrainedIndexes.append(enzymeUsageRate_colIndex)

				# Create pseudometabolite and flux for bool-constrained
				enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)
				enzymeEquivalentBool_rowIndex = self._rowNew(enzymeEquivalentBoolID)

				enzymeUsageBoolID = self._generatedID_enzymeUsageBoolConstrained.format(enzymeID)
				enzymeUsageBool_colIndex = self._colNew(enzymeUsageBoolID)

				self._rowIndexes.append(enzymeEquivalentBool_rowIndex)
				self._colIndexes.append(enzymeUsageBool_colIndex)
				self._values.append(+1)

				enzymeUsageBoolConstrainedIndexes.append(enzymeUsageBool_colIndex)


			for reactionID, enzymeID in reactionEnzymes.viewitems():
				reaction_colIndex = self._colIndex(reactionID)

				if reactionRates is not None and reactionRates.has_key(reactionID):
					reactionRate = reactionRates[reactionID]

					if reactionRate <= 0:
						raise FBAException("Reaction rates must be positive ({}, {})".format(reactionID, reactionRate))

					enzymesPerReaction = -1/reactionRate
					enzymeEquivalentRateID = self._generatedID_enzymeEquivRateConstrained.format(enzymeID)
					enzymeEquivalentRate_rowIndex = self._rowIndex(enzymeEquivalentRateID)

					self._rowIndexes.append(enzymeEquivalentRate_rowIndex)
					self._colIndexes.append(reaction_colIndex)
					self._values.append(enzymesPerReaction)
					

				else:
					enzymeEquivalentBoolID = self._generatedID_enzymeEquivBoolConstrained.format(enzymeID)
					enzymeEquivalentBool_rowIndex = self._rowIndex(enzymeEquivalentBoolID)

					self._rowIndexes.append(enzymeEquivalentBool_rowIndex)
					self._colIndexes.append(reaction_colIndex)
					self._values.append(-1)

		self._enzymeUsageRateConstrainedIndexes = np.array(enzymeUsageRateConstrainedIndexes, np.int64)
		self._enzymeUsageBoolConstrainedIndexes = np.array(enzymeUsageBoolConstrainedIndexes, np.int64)


	def _initMass(self, externalExchangedMolecules, moleculeMasses):
		"""Create mass accumulation abstractions.

		Tracking the mass entering the system through metabolism is crucial for
		insuring closure. It can also be used to constrain the maximal rate of
		growth."""

		if moleculeMasses is not None:
			massID = "Mass"
			massIndex = self._rowNew(massID)

			massOutIndex = self._colNew(self._massOutName)

			self._rowIndexes.append(massIndex)
			self._colIndexes.append(massOutIndex)
			self._values.append(-1)

			for moleculeID in externalExchangedMolecules:
				exchangeFluxName = self._generatedID_externalExchange.format(moleculeID)
				exchangeFluxIndex = self._colIndex(exchangeFluxName)

				try:
					moleculeMass = moleculeMasses[moleculeID]

				except KeyError:
					raise FBAException("You must provide masses for all molecules in externalExchangedMolecules")

				self._rowIndexes.append(massIndex)
				self._colIndexes.append(exchangeFluxIndex)
				self._values.append(-moleculeMass) # NOTE: negative because exchange fluxes point out


	def _finalizeMisc(self):
		"""Finalize values accumulated during the various _init* methods."""
		self._nEdges = len(self._colNames)
		self._nNodes = len(self._rowNames)

		self._outputMoleculeIDs = tuple([self._rowNames[index] for index in self._outputMoleculeIndexes])

		self._outputReactionIndexes = np.array(self._outputReactionIndexes)


	def _finalizeMatrices(self):
		"""Create the abstractions needed for linear programming and for 
		computing various outputs.

		Optimization problem:
		
		\max_v f^T x
		
		subject to
		b = Ax
		h >= Gx
		
		where b = 0"""

		# Create A matrix (stoichiometry + other things)

		self._A = cvxopt.spmatrix(self._values, self._rowIndexes, self._colIndexes)

		# Create objective function f

		objectiveFunction = np.zeros(self._nEdges, np.float64)

		objectiveFunction[self._objIndexes] = self._objValues

		if self._maximizeObjective:
			self._f = cvxopt.matrix(-objectiveFunction)

		else:
			self._f = cvxopt.matrix(objectiveFunction)

		self._lowerBound = np.empty(self._nEdges, np.float64)
		self._lowerBound.fill(self._lowerBoundDefault)
		self._lowerBound[self._lowerBoundIndexes] = self._lowerBoundValues

		self._upperBound = np.empty(self._nEdges, np.float64)
		self._upperBound.fill(self._upperBoundDefault)
		self._upperBound[self._upperBoundIndexes] = self._upperBoundValues

		self._G = cvxopt.matrix(np.concatenate(
			[np.identity(self._nEdges, np.float64), -np.identity(self._nEdges, np.float64)], axis = 0
			))

		self._b = cvxopt.matrix(np.zeros(self._nNodes, np.float64))

		# Create matrix for computing output
		self._outputCalcMatrix = -np.array(cvxopt.matrix(self._A[
			self._outputMoleculeIndexes, self._outputReactionIndexes.tolist() # NOTE: this type of indexing REQUIRES lists, not arrays
			]))


	def _colNew(self, colName):
		if colName in self._colNames:
			raise AlreadyExistsException("Edge already exists: {}".format(colName))

		else:
			self._colNames.append(colName)
			return len(self._colNames) - 1


	def _colIndex(self, colName, createIfDoesNotExists = False):
		try:
			return self._colNames.index(colName)

		except ValueError:
			if createIfDoesNotExists:
				return self._colNew(colName)

			else:
				raise DoesNotExistException("Edge does not exist: {}".format(colName))


	def _rowNew(self, rowName):
		if rowName in self._rowNames:
			raise AlreadyExistsException("Node already exists: {}".format(rowName))

		else:
			self._rowNames.append(rowName)
			return len(self._rowNames) - 1


	def _rowIndex(self, rowName, createIfDoesNotExists = False):
		try:
			return self._rowNames.index(rowName)

		except ValueError:
			if createIfDoesNotExists:
				return self._rowNew(rowName)

			else:
				raise DoesNotExistException("Node does not exist: {}".format(rowName))


	# Constraint setup

	# NOTE: I've used the nonspecific term "levels" since these could be
	# mole-concentration, number-concentration, or counts, depending on the 
	# formulation of the problem.  All that matters is that initialization 
	# parameters have consistent units.

	def externalMoleculeIDs(self):
		return self._externalMoleculeIDs


	def externalMoleculeLevelsIs(self, levels):
		levels = np.array(levels)
		if (levels < 0).any():
			raise InvalidBoundaryException("Negative molecule levels not allowed")

		self._lowerBound[self._externalExchangeIndexes] = -levels


	def internalMoleculeIDs(self):
		return self._internalMoleculeIDs


	def internalMoleculeLevelsIs(self, levels):
		levels = np.array(levels)
		if (levels < 0).any():
			raise InvalidBoundaryException("Negative molecule levels not allowed")

		self._lowerBound[self._internalExchangeIndexes] = -levels

		if self._forceInternalExchange:
			self._upperBound[self._internalExchangeIndexes] = -levels


	def enzymeIDs(self):
		return self._enzymeIDs


	def enzymeLevelsIs(self, levels):
		if self._enzymeUsageRateConstrainedIndexes.size == 0:
			return

		levelsArray = np.zeros(self._enzymeUsageRateConstrainedIndexes.size, np.float64)
		levelsArray[:] = levels
		if (levelsArray < 0).any():
			raise InvalidBoundaryException("Negative enzyme levels not allowed")

		# Rate-constrained
		self._upperBound[self._enzymeUsageRateConstrainedIndexes] = levelsArray

		# Boolean-constrained (enzyme w/o an annotated rate)
		boolConstraint = np.zeros(self._enzymeUsageBoolConstrainedIndexes.size, np.float64)
		boolConstraint[levelsArray > 0] = np.inf
		self._upperBound[self._enzymeUsageBoolConstrainedIndexes] = boolConstraint


	def reactionIDs(self):
		return np.array(self._colNames)[self._reactionIndexes]


	def maxReactionFluxIs(self, reactionID, maxFlux, raiseForReversible = True):
		colIndex = self._colIndex(reactionID)

		if maxFlux < 0:
			raise InvalidBoundaryException("Maximum reaction flux must be at least 0")

		if maxFlux < self._lowerBound[colIndex]:
			raise InvalidBoundaryException("Maximum reaction flux must be greater than or equal to the minimum flux")

		reverseReactionID = self._generatedID_reverseReaction.format(reactionID)

		if raiseForReversible and reverseReactionID in self._colNames:
			raise FBAException((
				"Setting the maximum reaction flux is ambiguous since " +
				"reaction {} has both a forward [{}] and reverse [{}] " +
				"component.  Call this method with argument " + 
				"raiseForReversible = False if this is intended behavior."
				).format(reactionID, reactionID, reverseReactionID))

		self._upperBound[colIndex] = maxFlux


	def minReactionFluxIs(self, reactionID, minFlux, raiseForReversible = True):
		colIndex = self._colIndex(reactionID)

		if minFlux < 0:
			raise InvalidBoundaryException("Maximum reaction flux must be at least 0")

		if minFlux > self._upperBound[colIndex]:
			raise InvalidBoundaryException("Minimum reaction flux must be less than or equal to the maximum flux")

		reverseReactionID = self._generatedID_reverseReaction.format(reactionID)

		if raiseForReversible and reverseReactionID in self._colNames:
			raise FBAException((
				"Setting the minimum reaction flux is ambiguous since " +
				"reaction {} has both a forward [{}] and reverse [{}] " +
				"component.  Call this method with argument " + 
				"raiseForReversible = False if this is intended behavior."
				).format(reactionID, reactionID, reverseReactionID))

		self._lowerBound[colIndex] = minFlux


	def objectiveIs(self, objective):
		for moleculeID, coeff in objective.viewitems():
			molecule_rowIndex = self._rowIndex(moleculeID)

			pseudoFluxID = self._generatedID_moleculesToEquivalents.format(moleculeID)
			colIndex = self._colIndex(pseudoFluxID)

			self._A[molecule_rowIndex, colIndex] = -coeff


	def maxMassAccumulatedIs(self, maxAccumulation):
		self._upperBound[self._colIndex(self._massOutName)] = maxAccumulation


	# Evaluation

	def run(self):
		h = cvxopt.matrix(np.fmin(
			np.concatenate([self._upperBound, -self._lowerBound], axis = 0),
			self._numericalInfinity
			))

		oldOptions = cvxopt.solvers.options.copy()

		cvxopt.solvers.options["LPX_K_MSGLEV"] = 0

		solution = cvxopt.solvers.lp(self._f, self._G, h, self._A, self._b, solver = "glpk")

		cvxopt.solvers.options.update(oldOptions)

		self._rawSolution = solution

		# TODO: raise/return flag on failed optimization

		self._solutionFluxes = np.array(self._rawSolution["x"]).flatten()


	# Output

	def outputMoleculeIDs(self):
		return self._outputMoleculeIDs


	def outputMoleculeLevelsChange(self):
		# Must compute and return two (potentially overlapping) sets of 
		# molecule counts:
		# - internal input usage (TODO)
		# - objective output production

		return np.dot(self._outputCalcMatrix, self._solutionFluxes[self._outputReactionIndexes])


	def externalExchangeFlux(self, moleculeID):
		return -self._solutionFluxes[
			self._colIndex(self._generatedID_externalExchange.format(moleculeID))
			]


	def externalExchangeFluxes(self):
		return -self._solutionFluxes[self._externalExchangeIndexes]


	def internalExchangeFlux(self, moleculeID):
		return -self._solutionFluxes[
			self._colIndex(self._generatedID_internalExchange.format(moleculeID))
			]


	def reactionFlux(self, reactionID):
		return self._solutionFluxes[self._colIndex(reactionID)]


	def reactionFluxes(self):
		return self._solutionFluxes[self._reactionIndexes]


	def objectiveReactionFlux(self):
		try:
			colIndex = self._colIndex(self._standardObjectiveReactionName)

		except DoesNotExistException:
			raise FBAException("No objective reaction flux implemented for this solver type")

		return self._solutionFluxes[colIndex]


	def objectiveValue(self):
		return self._rawSolution["primal objective"]


	def enzymeUsage(self):
		return self._solutionFluxes[self._enzymeUsageRateConstrainedIndexes]


	def massAccumulated(self):
		return self._solutionFluxes[self._colIndex(self._massOutName)]


# Test code

def _loadKB():
	import wholecell.reconstruction.knowledge_base_ecoli
	return wholecell.reconstruction.knowledge_base_ecoli.KnowledgeBaseEcoli()


def _setupFeist(kb):
	# Create the KB and parse into FBA inputs

	objectiveRaw = {
		'10fthf[c]' : -0.000223,
		'2ohph[c]' : -0.000223,
		'adp[c]' : 59.810000000000002,
		'ala-L[c]' : -0.51370000000000005,
		'amet[c]' : -0.000223,
		'arg-L[c]' : -0.29580000000000001,
		'asn-L[c]' : -0.24110000000000001,
		'asp-L[c]' : -0.24110000000000001,
		'atp[c]' : -59.984000000000002,
		'ca2[c]' : -0.0047369999999999999,
		'cl[c]' : -0.0047369999999999999,
		'coa[c]' : -0.00057600000000000001,
		'cobalt2[c]' : -0.0031580000000000002,
		'ctp[c]' : -0.13350000000000001,
		'cu2[c]' : -0.0031580000000000002,
		'cys-L[c]' : -0.091579999999999995,
		'datp[c]' : -0.026169999999999999,
		'dctp[c]' : -0.027019999999999999,
		'dgtp[c]' : -0.027019999999999999,
		'dttp[c]' : -0.026169999999999999,
		'fad[c]' : -0.000223,
		'fe2[c]' : -0.0071060000000000003,
		'fe3[c]' : -0.0071060000000000003,
		'gln-L[c]' : -0.26319999999999999,
		'glu-L[c]' : -0.26319999999999999,
		'gly[c]' : -0.61260000000000003,
		'gtp[c]' : -0.21510000000000001,
		'h2o[c]' : -54.462000000000003,
		'h[c]' : 59.810000000000002,
		'his-L[c]' : -0.094740000000000005,
		'ile-L[c]' : -0.29049999999999998,
		'k[c]' : -0.17760000000000001,
		'kdo2lipid4[e]' : -0.019449999999999999,
		'leu-L[c]' : -0.45050000000000001,
		'lys-L[c]' : -0.34320000000000001,
		'met-L[c]' : -0.1537,
		'mg2[c]' : -0.0078949999999999992,
		'mlthf[c]' : -0.000223,
		'mn2[c]' : -0.0031580000000000002,
		'mobd[c]' : -0.0031580000000000002,
		'murein5px4p[p]' : -0.01389,
		'nad[c]' : -0.0018309999999999999,
		'nadp[c]' : -0.00044700000000000002,
		'nh4[c]' : -0.011842999999999999,
		'pe160[c]' : -0.022329999999999999,
		'pe160[p]' : -0.041480000000000003,
		'pe161[c]' : -0.02632,
		'pe161[p]' : -0.048890000000000003,
		'phe-L[c]' : -0.1759,
		'pheme[c]' : -0.000223,
		'pi[c]' : 59.805999999999997,
		'ppi[c]' : 0.77390000000000003,
		'pro-L[c]' : -0.22109999999999999,
		'pydx5p[c]' : -0.000223,
		'ribflv[c]' : -0.000223,
		'ser-L[c]' : -0.21579999999999999,
		'sheme[c]' : -0.000223,
		'so4[c]' : -0.0039480000000000001,
		'thf[c]' : -0.000223,
		'thmpp[c]' : -0.000223,
		'thr-L[c]' : -0.25369999999999998,
		'trp-L[c]' : -0.056840000000000002,
		'tyr-L[c]' : -0.13789999999999999,
		'udcpdp[c]' : -5.5000000000000002e-05,
		'utp[c]' : -0.14410000000000001,
		'val-L[c]' : -0.42320000000000002,
		'zn2[c]' : -0.0031580000000000002,
		}

	objective = {}
	for moleculeID_raw, coeff in objectiveRaw.viewitems():
		moleculeID = moleculeID_raw[:-2].upper() + moleculeID_raw[-2:]

		if moleculeID == "KDO2LIPID4[e]":
			moleculeID = "KDO2LIPID4[o]"

		objective[moleculeID] = -coeff

	import re
	rxns = [
		x for x in kb.metabolismBiochemicalReactions
		if (
			not re.match(".*_[0-9]$", x["id"])
			or x["id"].endswith("_0")
			or "PFK_2" in x["id"]
			)
		]

	reactionStoich = {
		rxn["id"]:
		{entry["molecule"]+"["+entry["location"]+"]":entry["coeff"] for entry in rxn["stoichiometry"]}
		for rxn in rxns
		if len(rxn["stoichiometry"]) > 1 # no exchange reactions!
		}

	reversibleReactions = [rxn["id"] for rxn in rxns if not rxn["dir"]]

	mediaEx = kb.metabolismMediaEx

	externalExchangedMolecules = [rxn["met"] for rxn in mediaEx]

	atpId = "ATP[c]"

	reactionEnzymes = {
		reactionID:enzymeID
		for reactionID, enzymeID in izip(kb.metabolismReactionIds, kb.metabolismReactionEnzymes)
		if (enzymeID is not None) and reactionStoich.has_key(reactionID)
		}

	dt = 3600
	reactionRates = {
		reactionID:rate * dt
		for reactionID, rate in izip(kb.metabolismReactionIds, kb.metabolismReactionKcat)
		if reactionStoich.has_key(reactionID) and rate > 0
		}

	masses = kb.getMass(externalExchangedMolecules).asNumber(units.g / units.mmol)

	moleculeMasses = {moleculeID:masses[index]
		for index, moleculeID in enumerate(externalExchangedMolecules)}

	# Create FBA instance
	fba = FluxBalanceAnalysis(
		reactionStoich,
		externalExchangedMolecules,
		objective,
		objectiveType = "flexible",
		objectiveParameters = {
			"gamma":0.1,
			"beta":100,
			"leading molecule ID":atpId
			},
		reversibleReactions = reversibleReactions,
		reactionEnzymes = reactionEnzymes,
		reactionRates = reactionRates,
		moleculeMasses = moleculeMasses
		)

	# Set constraints
	## External molecules
	externalMoleculeIDs = fba.externalMoleculeIDs()

	unconstrainedExchange = ("CA2[e]", "CL[e]", "CO2[e]", "COBALT2[e]", 
		"CU2[e]", "FE2[e]", "FE3[e]", "H[e]", "H2O[e]", "K[e]", "MG2[e]",
		"MN2[e]", "MOBD[e]", "NA1[e]", "NH4[e]", "PI[e]", "SO4[e]", "TUNGS[e]",
		"ZN2[e]")

	constrainedExchange = {
		"CBL1[e]":0.01,
		"GLC-D[e]":8, # mmol/gdcw-hr
		"O2[e]":18.5
		}

	externalMoleculeLevels = np.zeros(len(externalMoleculeIDs), np.float64)

	for index, moleculeID in enumerate(externalMoleculeIDs):
		if moleculeID in unconstrainedExchange:
			externalMoleculeLevels[index] = np.inf

		elif constrainedExchange.has_key(moleculeID):
			externalMoleculeLevels[index] = constrainedExchange[moleculeID]

	fba.externalMoleculeLevelsIs(externalMoleculeLevels)

	## Set Feist's forced reactions

	### ATP maintenance
	fba.minReactionFluxIs("FEIST_ATPM", 8.39)
	fba.maxReactionFluxIs("FEIST_ATPM", 8.39)

	### Arbitrarily disabled reactions
	disabledReactions = ("FEIST_CAT_0", "FEIST_SPODM_0", "FEIST_SPODMpp", "FEIST_FHL_0_0", "FEIST_FHL_1_0")

	for reactionID in disabledReactions:
		fba.maxReactionFluxIs(reactionID, 0)

	## Set enzymes unlimited
	fba.enzymeLevelsIs(np.inf)

	return fba


def _compareFeistToExpected():
	kb = _loadKB()

	fba = _setupFeist(kb)

	# Run model
	fba.run()

	# Output
	print fba.externalExchangeFlux("GLC-D[e]"), "(expected 8.)"
	print fba.externalExchangeFlux("O2[e]"), "(expected 16.27631182)"
	print fba.objectiveReactionFlux(), "(expected 0.73645239)"

	print "Imported mass: ", fba.massAccumulated()


def _checkEnzymeLimitations():
	kb = _loadKB()

	fba = _setupFeist(kb)

	fba.run()

	cellDryGrams = kb.avgCellDryMassInit.asNumber(units.g)
	moleculesPerMole = kb.nAvogadro.asNumber()

	enzymeUsageMolecules = fba.enzymeUsage() * moleculesPerMole * cellDryGrams

	import ipdb; ipdb.set_trace()


if __name__ == "__main__":
	_compareFeistToExpected()
