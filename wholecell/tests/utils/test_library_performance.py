"""
Test library performance (NumPy and libraries above and below it) to
discover configuration problems such as performance bugs in some versions
of pip packages or problems linking to native libraries. Precise timings
aren't needed.

Running it this way prints all timing measurements:
	python -m wholecell.tests.utils.test_library_performance

Running it these ways prints timing measurements (and other printout) only
for failed tests, e.g. those that exceed their @nose.tools.timed()
thresholds:
	nosetests wholecell/tests/utils/test_library_performance.py
	nosetests -a performance

Running it this way runs the iterative test that isn't automatically
discovered as a test method:
	python -m unittest -v wholecell.tests.utils.test_library_performance.Test_library_performance.multitest_dot
"""

import resource
import time
import unittest

import numpy as np
import scipy.integrate
import nose.plugins.attrib as noseAttrib
import nose.tools


def clock2():
	"""
	clock2() -> (ru_utime, ru_stime)

	Return the TOTAL (USER, SYSTEM CPU) time in floating point seconds
	since the start of the process, excluding any child processes. The
	data comes from resource.getrusage() so it avoids the wraparound
	problems in time.clock().

	FYI: getrusage() also returns memory usage data.

	Cf. IPython %time magic github.com/ipython/ipython -
	IPython/core/magics/execution.py
	"""
	usage = resource.getrusage(resource.RUSAGE_SELF)
	return usage.ru_utime, usage.ru_stime

def _format_time(timespan, precision=3):
	"""
	Formats the timespan in a human-readable form.

	Cf. IPython %time magic
	github.com/ipython/ipython - IPython/core/magics/execution.py
	"""

	if timespan >= 60.0:
		# More than a minute. Format it in a human readable form.
		PARTS = (("d", 60 * 60 * 24), ("h", 60 * 60), ("min", 60), ("s", 1))
		time_parts = []
		leftover = timespan
		for (suffix, length) in PARTS:
			value = int(leftover / length)
			if value > 0:
				leftover = leftover % length
				time_parts.append("%s%s" % (str(value), suffix))
			if leftover < 1:
				break
		return " ".join(time_parts)

	UNITS = ("s", "ms", "us", "ns")
	SCALING = (1, 1e3, 1e6, 1e9)
	K = 3  # orders of magnitude between SCALING factors

	if timespan > 0.0:
		order = min(-int(np.floor(np.log10(timespan)) // K), K)
	else:
		order = K
	return "%.*g %s" % (precision, timespan * SCALING[order], UNITS[order])


def time_it(code_to_measure, title='Measured'):
	"""
	Times the execution of code_to_measure().
	Cf. IPython %time magic
	github.com/ipython/ipython - IPython/core/magics/execution.py time()
	"""
	wall_clock = time.time

	# time execution
	wall_start = wall_clock()
	(start_user, start_sys) = clock2()
	code_to_measure()
	(end_user, end_sys) = clock2()
	wall_end = wall_clock()

	wall_time = wall_end - wall_start
	cpu_user = end_user - start_user
	cpu_sys = end_sys - start_sys
	cpu_total = cpu_user + cpu_sys

	print("\n%s CPU times: user %s, sys: %s, total: %s; Wall time: %s"
		  % (title, _format_time(cpu_user), _format_time(cpu_sys),
			 _format_time(cpu_total), _format_time(wall_time)))


# Originally generated by the fitter into
# reconstruction/ecoli/dataclasses/process/two_component_system_odes_fitter.py
#
# TODO(jerry): Use smaller matrices for this test.
#
# TODO(jerry): In the original fitter-generated code, remove the `**1.0`
# terms. In both, factor out common subexpressions and constants?
#
# TODO(jerry): Try JIT-compiling this with Numba.
#
# TODO(jerry): Format to a shorter source code line length?
def derivatives(y, t):
	return np.array([
		[-100000000.0*y[0]*y[6] + 500.0*y[3]*y[4]], [0], [0],
		[100000000.0*y[0]*y[6] - 500.0*y[3]*y[4]], [0],
		[100000000.0*y[0]*y[6] - 0.01*y[5]*y[8]],
		[-100000000.0*y[0]*y[6] + 0.01*y[5]*y[8]], [0], [0],
		[170000.0*y[10]*y[4] - 100000000.0*y[12]*y[9]],
		[-170000.0*y[10]*y[4] + 100000000.0*y[12]*y[9]],
		[-0.01*y[11]*y[8] + 100000000.0*y[12]*y[13] + 100000000.0*y[12]*y[9]],
		[0.01*y[11]*y[8] - 100000000.0*y[12]*y[13] - 100000000.0*y[12]*y[9]],
		[-100000000.0*y[12]*y[13] + 0.0001*y[14]*y[4]],
		[100000000.0*y[12]*y[13] - 0.0001*y[14]*y[4]],
		[-100000000.0*y[15]*y[18] + 170000.0*y[16]*y[4]],
		[100000000.0*y[15]*y[18] - 170000.0*y[16]*y[4]],
		[100000000.0*y[15]*y[18] - 0.01*y[17]*y[8] + 100000000.0*y[18]*y[19]],
		[-100000000.0*y[15]*y[18] + 0.01*y[17]*y[8] - 100000000.0*y[18]*y[19]],
		[-100000000.0*y[18]*y[19] + 0.0001*y[20]*y[4]],
		[100000000.0*y[18]*y[19] - 0.0001*y[20]*y[4]],
		[-100000000.0*y[21]*y[24] + 170000.0*y[22]*y[4]],
		[100000000.0*y[21]*y[24] - 170000.0*y[22]*y[4]],
		[100000000.0*y[21]*y[24] - 0.01*y[23]*y[8] + 100000000.0*y[24]*y[25]],
		[-100000000.0*y[21]*y[24] + 0.01*y[23]*y[8] - 100000000.0*y[24]*y[25]],
		[-100000000.0*y[24]*y[25] + 0.0001*y[26]*y[4]],
		[100000000.0*y[24]*y[25] - 0.0001*y[26]*y[4]],
		[-100000000.0*y[27]*y[30] + 170000.0*y[28]*y[4]],
		[100000000.0*y[27]*y[30] - 170000.0*y[28]*y[4]],
		[100000000.0*y[27]*y[30] - 0.01*y[29]*y[8] + 100000000.0*y[30]*y[31]],
		[-100000000.0*y[27]*y[30] + 0.01*y[29]*y[8] - 100000000.0*y[30]*y[31]],
		[-100000000.0*y[30]*y[31] + 0.0001*y[32]*y[4]],
		[100000000.0*y[30]*y[31] - 0.0001*y[32]*y[4]],
		[-100000000.0*y[33]*y[36] + 500.0*y[34]*y[4]],
		[100000000.0*y[33]*y[36] - 500.0*y[34]*y[4]],
		[100000000.0*y[33]*y[36] - 0.01*y[35]*y[8]],
		[-100000000.0*y[33]*y[36] + 0.01*y[35]*y[8]],
		[-100000000.0*y[37]*y[40] + 500.0*y[38]*y[4]],
		[100000000.0*y[37]*y[40] - 500.0*y[38]*y[4]],
		[100000000.0*y[37]*y[40] - 0.01*y[39]*y[8]],
		[-100000000.0*y[37]*y[40] + 0.01*y[39]*y[8]]]).reshape(-1)

# Ditto.
def derivativesJacobian(y, t):
	return np.array([
		[-100000000.0*y[6], 0, 0, 500.0*y[4], 500.0*y[3], 0, -100000000.0*y[0], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[100000000.0*y[6], 0, 0, -500.0*y[4], -500.0*y[3], 0, 100000000.0*y[0], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[100000000.0*y[6], 0, 0, 0, 0, -0.01*y[8], 100000000.0*y[0], 0, -0.01*y[5], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[-100000000.0*y[6], 0, 0, 0, 0, 0.01*y[8], -100000000.0*y[0], 0, 0.01*y[5], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 170000.0*y[10], 0, 0, 0, 0, -100000000.0*y[12], 170000.0*y[4], 0, -100000000.0*y[9], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -170000.0*y[10], 0, 0, 0, 0, 100000000.0*y[12], -170000.0*y[4], 0, 100000000.0*y[9], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, -0.01*y[11], 100000000.0*y[12], 0, -0.01*y[8], 100000000.0*y[13] + 100000000.0*y[9], 100000000.0*y[12], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0.01*y[11], -100000000.0*y[12], 0, 0.01*y[8], -100000000.0*y[13] - 100000000.0*y[9], -100000000.0*y[12], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0.0001*y[14], 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[13], -100000000.0*y[12], 0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -0.0001*y[14], 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[13], 100000000.0*y[12], -0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 170000.0*y[16], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[18], 170000.0*y[4], 0, -100000000.0*y[15], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -170000.0*y[16], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[18], -170000.0*y[4], 0, 100000000.0*y[15], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, -0.01*y[17], 0, 0, 0, 0, 0, 0, 100000000.0*y[18], 0, -0.01*y[8], 100000000.0*y[15] + 100000000.0*y[19], 100000000.0*y[18], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0.01*y[17], 0, 0, 0, 0, 0, 0, -100000000.0*y[18], 0, 0.01*y[8], -100000000.0*y[15] - 100000000.0*y[19], -100000000.0*y[18], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0.0001*y[20], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[19], -100000000.0*y[18], 0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -0.0001*y[20], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[19], 100000000.0*y[18], -0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 170000.0*y[22], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[24], 170000.0*y[4], 0, -100000000.0*y[21], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -170000.0*y[22], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[24], -170000.0*y[4], 0, 100000000.0*y[21], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, -0.01*y[23], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[24], 0, -0.01*y[8], 100000000.0*y[21] + 100000000.0*y[25], 100000000.0*y[24], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0.01*y[23], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[24], 0, 0.01*y[8], -100000000.0*y[21] - 100000000.0*y[25], -100000000.0*y[24], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0.0001*y[26], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[25], -100000000.0*y[24], 0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -0.0001*y[26], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[25], 100000000.0*y[24], -0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 170000.0*y[28], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[30], 170000.0*y[4], 0, -100000000.0*y[27], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -170000.0*y[28], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[30], -170000.0*y[4], 0, 100000000.0*y[27], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, -0.01*y[29], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[30], 0, -0.01*y[8], 100000000.0*y[27] + 100000000.0*y[31], 100000000.0*y[30], 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0.01*y[29], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[30], 0, 0.01*y[8], -100000000.0*y[27] - 100000000.0*y[31], -100000000.0*y[30], 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0.0001*y[32], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[31], -100000000.0*y[30], 0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, -0.0001*y[32], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[31], 100000000.0*y[30], -0.0001*y[4], 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 500.0*y[34], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[36], 500.0*y[4], 0, -100000000.0*y[33], 0, 0, 0, 0],
		[0, 0, 0, 0, -500.0*y[34], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[36], -500.0*y[4], 0, 100000000.0*y[33], 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, -0.01*y[35], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[36], 0, -0.01*y[8], 100000000.0*y[33], 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0.01*y[35], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[36], 0, 0.01*y[8], -100000000.0*y[33], 0, 0, 0, 0],
		[0, 0, 0, 0, 500.0*y[38], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[40], 500.0*y[4], 0, -100000000.0*y[37]],
		[0, 0, 0, 0, -500.0*y[38], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[40], -500.0*y[4], 0, 100000000.0*y[37]],
		[0, 0, 0, 0, 0, 0, 0, 0, -0.01*y[39], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000000.0*y[40], 0, -0.01*y[8], 100000000.0*y[37]],
		[0, 0, 0, 0, 0, 0, 0, 0, 0.01*y[39], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100000000.0*y[40], 0, 0.01*y[8], -100000000.0*y[37]]])


class Test_library_performance(unittest.TestCase):
	"""Test some library operations to see that they're performing OK."""

	def time_this(self, code_to_measure):
		"""Times the execution of code_to_measure()."""
		test_method_name = self.id().rpartition('.')[-1]
		time_it(code_to_measure, test_method_name)

	# On 2015 MacBook Pro this takes < 25 ms.
	# On Sherlock 1.0 with 1 CPU this takes ~250 ms.
	# On Sherlock 1.0 with 16 CPUs this takes 50 - 100 ms.
	# Allow time for test framework overhead + matrix construction.
	@noseAttrib.attr('performance')
	@nose.tools.timed(0.35)
	def test_dot(self):
		"""Time NumPy matrix dot()."""
		M = np.random.random(size=(1000, 1000))
		self.time_this(lambda: M.dot(M))

	@noseAttrib.attr('performance')
	def multitest_dot(self):
		"""Time NumPy matrix dot() many times."""
		for iteration in xrange(100):
			self.test_dot()

	# On 2015 MacBook Pro this takes < 200 ms.
	# On Sherlock 1.0 with 1 CPU this takes TBD ms.
	# On Sherlock 1.0 with 16 CPUs this takes TBD ms.
	# Allow time for test framework overhead + matrix construction.
	@noseAttrib.attr('performance')
	@nose.tools.timed(2.8)
	def test_odeint(self):
		"""Time scipy.integrate.odeint()."""
		y0 = np.random.random(41)

		def odeint():
			y = scipy.integrate.odeint(
				derivatives, y0, t=[0, 1e6], Dfun=derivativesJacobian,
				mxstep=10000)
		self.time_this(odeint)


if __name__ == '__main__':
	unittest.main()
